QA output created by 273
--- help.c case 1 ---
sampledso.control [A control variable for the "sample" PMDA]
sampledso.daemon_pid [Process id of PMDA daemon]
sampledso.seconds [Elapsed time (seconds)]
sampledso.milliseconds [Elapsed time (milliseconds)]
sampledso.load [Hypothetical load]
sampledso.colour [Metrics with a "saw-tooth" trend over time]
sampledso.darkness [No values available]
sampledso.bin [Several constant instances]
sampledso.bucket [Several constant instances]
sampledso.part_bin [Several constant instances]
sampledso.bogus_bin [Several constant instances]
sampledso.drift [A random trended metric]
sampledso.step [A step function (instantaneous)]
sampledso.step_counter [A step function (counter)]
sampledso.mirage [Simple saw-tooth rate, but instances come and go]
sampledso.mirage_longlong [Simple saw-tooth rate, but instances come and go]
sampledso.write_me [Modifiable, but otherwise constant.]
sampledso.lights [Traffic lights.]
sampledso.magnitude [Powers of two.]
sampledso.sysinfo [Aggregate containing system accounting structures]
sampledso.pdu [Total PDU count]
sampledso.recv_pdu [Count of PDUs received]
sampledso.xmit_pdu [Count of PDUs transmitted]
sampledso.noinst [No instance available]
sampledso.needprofile [Metrics that need an explicit profile]
sampledso.not_ready [interval (in seconds) during which PMDA does not respond to PDUs]
sampledso.rapid [count very quickly]
sampledso.error_code [Arbitrary PMAPI error code for sample.error_check]
sampledso.error_check [Return PMAPI error code from sample.error_code]
sampledso.bigid [a metric with item number bigger then 2^9]
sampledso.byte_ctr [counter byte counter]
sampledso.byte_rate [instantaneous bytes/second ]
sampledso.kbyte_ctr [counter Kbytes/second]
sampledso.kbyte_rate [instantaneous Kbytes/second]
sampledso.byte_rate_perhour [instantaneous bytes/hour]
sampledso.datasize [Space allocated for PMDA's data segment]
sampledso.secret.foo.bar.max.redirect One-line Help: Error: No PMCD agent for domain of request
sampledso.secret.foo.bar.three [dynamic *.secret.foo.bar.three metric]
sampledso.secret.foo.bar.four [dynamic *.secret.foo.bar.four metric]
sampledso.secret.foo.bar.grunt.five [dynamic *.secret.foo.bar.grunt.five metric]
sampledso.secret.foo.bar.grunt.snort.six [dynamic *.secret.foo.bar.grunt.snort.six metric]
sampledso.secret.foo.bar.grunt.snort.huff.puff.seven [dynamic *.secret.foo.bar.grunt.snort.huff.puff.seven metric]
sampledso.secret.foo.one [dynamic *.secret.foo.one metric]
sampledso.secret.foo.two [dynamic *.secret.foo.two metric]
sampledso.secret.bar [dynamic *.secret.bar metric]
sampledso.long.one [1 as a 32-bit integer]
sampledso.long.ten [10 as a 32-bit integer]
sampledso.long.hundred [100 as a 32-bit integer]
sampledso.long.million [1000000 as a 32-bit integer]
sampledso.long.write_me [a 32-bit integer that can be modified]
sampledso.long.bin [like sample.bin but type 32]
sampledso.long.bin_ctr [like sample.bin but type 32, SEM_COUNTER and SPACE_KBYTE]
sampledso.ulong.one [1 as a 32-bit unsigned integer]
sampledso.ulong.ten [10 as a 32-bit unsigned integer]
sampledso.ulong.hundred [100 as a 32-bit unsigned integer]
sampledso.ulong.million [1000000 as a 32-bit unsigned integer]
sampledso.ulong.write_me [a 32-bit unsigned integer that can be modified]
sampledso.ulong.bin [like sample.bin but type U32]
sampledso.ulong.bin_ctr [like sample.bin but type U32, SEM_COUNTER and SPACE_KBYTE]
sampledso.ulong.count.base [count scale is 1, value is 42,000,000]
sampledso.ulong.count.deca [count scale is 10, value is 4,200,000]
sampledso.ulong.count.hecto [count scale is 10, value is 420,000]
sampledso.ulong.count.kilo [count scale is 10, value is 42,000]
sampledso.ulong.count.mega [count scale is 10, value is 42]
sampledso.longlong.one [1 as a 64-bit integer]
sampledso.longlong.ten [10 as a 64-bit integer]
sampledso.longlong.hundred [100 as a 64-bit integer]
sampledso.longlong.million [1000000 as a 64-bit integer]
sampledso.longlong.write_me [a 64-bit integer that can be modified]
sampledso.longlong.bin [like sample.bin but type 64]
sampledso.longlong.bin_ctr [like sample.bin but type 64, SEM_COUNTER and SPACE_KBYTE]
sampledso.ulonglong.one [1 as a 64-bit unsigned integer]
sampledso.ulonglong.ten [10 as a 64-bit unsigned integer]
sampledso.ulonglong.hundred [100 as a 64-bit unsigned integer]
sampledso.ulonglong.million [1000000 as a 64-bit unsigned integer]
sampledso.ulonglong.write_me [a 64-bit unsigned integer that can be modified]
sampledso.ulonglong.bin [like sample.bin but type U64]
sampledso.ulonglong.bin_ctr [like sample.bin but type U64, SEM_COUNTER and SPACE_KBYTE]
sampledso.float.one [1 as a 32-bit floating point value]
sampledso.float.ten [10 as a 32-bit floating point value]
sampledso.float.hundred [100 as a 32-bit floating point value]
sampledso.float.million [1000000 as a 32-bit floating point value]
sampledso.float.write_me [a 32-bit floating-point value that can be modified]
sampledso.float.bin [like sample.bin but type FLOAT]
sampledso.float.bin_ctr [like sample.bin but type FLOAT, SEM_COUNTER and SPACE_KBYTE]
sampledso.double.one [1 as a 64-bit floating point value]
sampledso.double.ten [10 as a 64-bit floating point value]
sampledso.double.hundred [100 as a 64-bit floating point value]
sampledso.double.million [1000000 as a 64-bit floating point value]
sampledso.double.write_me [a 64-bit floating-point value that can be modified]
sampledso.double.bin [like sample.bin but type DOUBLE]
sampledso.double.bin_ctr [like sample.bin but type DOUBLE, SEM_COUNTER and SPACE_KBYTE]
sampledso.string.null [a zero length string]
sampledso.string.hullo [K&R have a lot to answer for]
sampledso.string.write_me [a string value that can be modified]
sampledso.string.bin [a string-valued version of sample.bin]
sampledso.aggregate.null [a zero length aggregate]
sampledso.aggregate.hullo [K&R have a lot to answer for]
sampledso.aggregate.write_me [a aggregate value that can be modified]
sampledso.hordes.one [500 instances]
sampledso.hordes.two [500 instances]
sampledso.bad.unknown [Not known to the PMDA]
sampledso.bad.nosupport [Not supported in this version of the PMDA]
sampledso.bad.novalues [Scalar with no values, ever]
sampledso.bad.fetch.again [Fetch returns PM_ERR_AGAIN, always]
sampledso.wrap.long [long counter that wraps]
sampledso.wrap.ulong [unsigned long counter that wraps]
sampledso.wrap.longlong [long long counter that wraps]
sampledso.wrap.ulonglong [unsigned long long counter that wraps]
sampledso.dodgey.control [control values retured for sample.dodgey.value]
sampledso.dodgey.value [5 unreliable instances]
sampledso.dynamic.counter [counter metric with dynamic indom]
sampledso.dynamic.discrete [discrete metric with dynamic indom]
sampledso.dynamic.instant [instant metric with dynamic indom]
sampledso.dynamic.meta.metric [metric with modifiable metadata]
sampledso.dynamic.meta.pmdesc.type [pmDesc.type for sample.dynamic.meta.metric]
sampledso.dynamic.meta.pmdesc.indom [pmDesc.indom for sample.dynamic.meta.metric]
sampledso.dynamic.meta.pmdesc.sem [pmDesc.sem for sample.dynamic.meta.metric]
sampledso.dynamic.meta.pmdesc.units [pmDesc.units for sample.dynamic.meta.metric]
sampledso.scale_step.bytes_up [count up by powers of 2, wrap back to one at 10 Tbytes]
sampledso.scale_step.bytes_down [count down by powers of 2, wrap back to 10 Tbytes at 1]
sampledso.scale_step.count_up [count up by powers of 10, wrap back to 1 at 10e12]
sampledso.scale_step.count_down [count down by powers of 10, wrap back to 10e12 at 1]
sampledso.scale_step.time_up_secs [count up seconds by multiples of 10, wrap back to 1 second at 1 day]
sampledso.scale_step.time_up_nanosecs [count up nanoseconds by multiples of 10, wrap back to 1 nanosecond at 1 day]
sampledso.scale_step.none_up [count up dimensionless by multiples of 10, wrap back to 1 at 10 million]
sampledso.const_rate.value [constant rate counter]
sampledso.const_rate.gradient [rate per second to set sample.const_rate.value, writable]
sampledso.many.count [number of instances in sample.many.int's domain]
sampledso.many.int [variable sized instance domain]
sampledso.scramble.version [Current state version and reset for sample.scramble.bin]
sampledso.scramble.bin [Several constant instances, instances scrambled]
sampledso.percontext.pdu [Total PDU count for the client context]
sampledso.percontext.recv_pdu [Count of PDUs received from the client context]
sampledso.percontext.xmit_pdu [Count of PDUs transmitted]
sampledso.percontext.control.ctx [Number of PMAPI contexts seen]
sampledso.percontext.control.active [Number of active PMAPI contexts]
sampledso.percontext.control.start [Number of new PMAPI contexts seen]
sampledso.percontext.control.end [Number of PMAPI contexts closed]
sampledso.event.records [Dummy event records]
sampledso.event.highres_records [Dummy highres timestamp event records]
sampledso.event.no_indom_records [More dummy event records]
sampledso.event.reset [reset event record state]
sampledso.event.reset_highres [reset highres event record state]
sampledso.event.type [event type parameter for event records]
sampledso.event.param_32 [32 parameter for event records]
sampledso.event.param_u32 [U32 parameter for event records]
sampledso.event.param_64 [64 parameter for event records]
sampledso.event.param_u64 [U64 parameter for event records]
sampledso.event.param_float [FLOAT parameter for event records]
sampledso.event.param_double [DOUBLE parameter for event records]
sampledso.event.param_string [STRING parameter for event records]
sampledso.event.param_aggregate [AGGREGATE parameter for event records]
sampledso.dupnames.daemon_pid [Process id of PMDA daemon]
sampledso.dupnames.pid_daemon [Process id of PMDA daemon]
sampledso.dupnames.two.seconds [Elapsed time (seconds)]
sampledso.dupnames.two.bin [Several constant instances]
sampledso.dupnames.two.write_me [Modifiable, but otherwise constant.]
sampledso.dupnames.two.lights [Traffic lights.]
sampledso.dupnames.two.float.ten [10 as a 32-bit floating point value]
sampledso.dupnames.two.double.ten [10 as a 64-bit floating point value]
sampledso.dupnames.three.bin [Several constant instances]
sampledso.dupnames.three.write_me [Modifiable, but otherwise constant.]
sampledso.negative.ctr.m_32 [32-bit integer counter metric with negative value]
sampledso.negative.ctr.m_64 [64-bit integer counter metric with negative value]
sampledso.negative.ctr.m_float [float counter metric with negative value]
sampledso.negative.ctr.m_double [double counter metric with negative value]
sampledso.negative.instant.m_32 [32-bit integer instantaneous metric with negative value]
sampledso.negative.instant.m_64 [64-bit integer instantaneous metric with negative value]
sampledso.negative.instant.m_float [float instantaneous metric with negative value]
sampledso.negative.instant.m_double [double instantaneous metric with negative value]
sampledso.negative.discrete.m_32 [32-bit integer discrete metric with negative value]
sampledso.negative.discrete.m_64 [64-bit integer discrete metric with negative value]
sampledso.negative.discrete.m_float [float discrete metric with negative value]
sampledso.negative.discrete.m_double [double discrete metric with negative value]
--- help.c case 2 ---

sampledso.control
Help:
This control variable may be modified using pmStore().
The allowed values are
    0	disable debugging output in the PMDA
    >0	value is interpreted as a vector of bit-fields to set
        old-style debugging options, see pmdbg -o -l for mapping
	from values to debugging options
    -1	force the PMDA to terminate

sampledso.daemon_pid
Help:
The process id of PMDA daemon, -1 if the daemon is a DSO.

sampledso.seconds
Help:
The elapsed time since the PMDA started, in seconds, i.e. as returned
by time(2).

sampledso.milliseconds
Help:
The elapsed time since the PMDA started, in milliseconds, i.e. as
returned by gettimeofday(2), and then adjusted from microseconds
to milliseconds.

sampledso.load
Help:
The hypothetical load is always 42!

sampledso.colour
Help:
This metric has 3 instances, designated "red", "green" and "blue".

The value of the metric is monotonic increasing in the range N to
N+100, then back to N.  The different instances have different N
values, namely 100 (red), 200 (green) and 300 (blue).

The underlying counter starts at 0 and is incremented once
for each pmFetch() to this metric and/or sampledso.mirage and/or
sampledso.mirage_longlong.

Use pmStore() to modify the underlying counter (independent of which
instance or instances are used).

sampledso.darkness
Help:
Defined over the same instance domain as sampledso.colour, but this
metric returns the "No values available" error for every fetch.

sampledso.bin
Help:
9 instances labelled "bin-100" thru "bin-900", each with an
initial value of 100 thru 900.

pmstore(1) may be used to change the values of some or all of
the instances, but note this will also change the values of the
metrics that share the same underlying values, i.e. sampledso.bucket,
sampledso.part_bin, sample.bogus_bin, sample.scramble.bin
sampledso.long.bin, sample.long.bin_ctr, sample.ulong.bin,
sampledso.ulong.bin_ctr, sample.longlong.bin, sample.longlong.bin_ctr,
sampledso.ulonglong.bin, sample.ulonglong.bin_ctr, sample.float.bin,
sampledso.float.bin_ctr, sample.double.bin, sample.double.bin_ctr
and sampledso.string.bin.

sampledso.bucket
Help:
9 instances labelled "bin-100" thru "bin-900", each with a constant
value of 100 thru 900.  This is an alias for sampledso.bin, but with
a different PMID.

sampledso.part_bin
Help:
5 instances labelled "bin-100" thru "bin-900", each with a constant
value of 100 thru 900.  This is defined over the same domain as
sampledso.part, but half of the instances are missing.

sampledso.bogus_bin
Help:
9 instances labelled "bin-100" thru "bin-900", each with a constant
value of 100 thru 900.  This is defined over the same domain as
sampledso.part, half the values are for instances not in the instance
domain.

sampledso.drift
Help:
This metric returns a random value (expected mean is approximately 200),
subject to a trending pattern such that the sequence is mainly monotonic,
with a change in direction after on average 4 consecutive sampledsos.

Use pmStore() to modify the instantaneous value, which becomes the new
expected mean.

sampledso.step
Help:
This metric changes magnitude every 30 seconds, between a base value and
3 times the base value.

The metric has "instantaneous" semantics.  See also sampledso.step_counter.

Use pmStore() to modify the base value.

sampledso.step_counter
Help:
This metric changes magnitude every 30 seconds, between a base value and
3 times the base value.

The metric has "counter" semantics.  See also sampledso.step.

Use pmStore() to modify the base value.

sampledso.mirage
Help:
The metric is a rate (Kbytes/sec) that varies in a saw-tooth distribution
over time.  Different instances of the metric have different baselines
for the saw-tooth, but all have an max-to-min range of 100.

What makes this metric interesting is that instances come and go (not
more often than once every 10 seconds however).  Instance 0 is always
present, but the other instances 1 thru 49 come and go in a cyclic
pattern with a large random component influencing when each instance
appears and disappears.

The underlying counter starts at 0 and is incremented once
for each pmFetch() to this metric and/or sampledso.colour and/or
sampledso.mirage_longlong.

Use pmStore() to modify the underlying counter (independent of which
instance or instances are used).

sampledso.mirage_longlong
Help:
The metric is a rate (bytes/msec) that varies in a saw-tooth distribution
over time.  Different instances of the metric have different baselines
for the saw-tooth, but all have an max-to-min range of 100,000,000.

What makes this metric interesting is that instances come and go (not more
often than once every 10 seconds however).  Instance 0 is always present,
but the other instances 1 thru 49 come and go in a cyclic pattern with
a large random component influencing when each instance appears and
disappears.

The underlying counter starts at 0 and is incremented once for each
pmFetch() to this metric and/or sampledso.mirage and/or sample.colour.

Use pmStore() to modify the underlying counter (independent of which
instance or instances are used).

sampledso.write_me
Help:
This metric has a 32-bit integer value of 2, unless changed via pmStore.
The metric has semantics of rate, and units of events per second.

sampledso.lights
Help:
A singular metric that has a discrete string value, namely "red",
"yellow" or "green".  There is some persistance in the value, so
consecutive fetches are likely to return the same value, however over a
long period of time all values are equally probable.

sampledso.magnitude
Help:
A singular metric that has a discrete integer value, namely 1, 2, 4, 8,
16, 32 or 64.  There is some persistance in the value, so consecutive
fetches are likely to return the same value, however over a long period
of time all values are equally probable.

sampledso.sysinfo
Help:
This metric has an aggregate value containing the following struct:
    struct {
        int		len;
        struct sysinfo	sysinfo;
    };

The len field contains the size of the structure enclosing it.
The sysinfo field contains various system accounting structures, summed over
all CPUs, as returned by
    sysmp(MP_SAGET, MPSA_SINFO, ...);

See /usr/include/sys/sysinfo.h for the definition of the sysinfo struct.

sampledso.pdu
Help:
Count of PDUs received or transmitted.

Use pmStore() to reset the counter to 0, independent of the value passed
to pmStore().

sampledso.recv_pdu
Help:
Count of PDUs received.

Use pmStore() to reset the counter to 0, independent of the value passed
to pmStore().

sampledso.xmit_pdu
Help:
Count of PDUs transmitted.

Use pmStore() to reset the counter to 0, independent of the value passed
to pmStore().

sampledso.noinst
Help:
For testing, only.  This metric is known, but no value is ever available

sampledso.needprofile
Help:
Simulate behaviour similar to the "proc" PMDA where metrics values are
only available if an explicit instance profile is provided.

sampledso.not_ready
Help:
Store a positive number of seconds as the value of this metric. The
following PDU received will result in the following sequence of events:
  1. return an error PDU with PM_ERR_PMDANOTREADY to pmcd
  2. sleep for the given number of seconds
  3. sends an error PDU with PM_ERR_PMDAREADY to pmcd
If everything went as planned, sampledso.not_ready returns to 0, otherwise it
has a negative error code as value.

sampledso.rapid
Help:
Base counter increments by 8*10^7 per fetch.  Result is 10 x base counter.

sampledso.error_code
Help:
The metrics sampledso.error_code and sample.error_check are used in tandem
as follows:
    if sampledso.error_code is < 0, then any attempt to retrieve
    information about sampledso.error_check will return a
    sampledso.error_code as a PMAPI error from the PMDA.

Use pmstore(1) to change sampledso.error_code.

sampledso.error_check
Help:
The metrics sampledso.error_code and sample.error_check are used in tandem
as follows:
    if sampledso.error_code is < 0, then any attempt to retrieve
    information about sampledso.error_check will return a
    sampledso.error_code as a PMAPI error from the PMDA.

Otherwise sampledso.error_check is a boring metric that always has
the value 0.

sampledso.bigid
Help:
a metric with item number bigger then 2^9

sampledso.byte_ctr
Help:
value increments randomly in the range (0,1023) bytes per fetch

sampledso.byte_rate
Help:
random value in the range (0,1023), so avg value is 512 bytes/second

sampledso.kbyte_ctr
Help:
value increments randomly in the range (0,1023) Kbytes per fetch

sampledso.kbyte_rate
Help:
random value in the range (0,1023), so avg value is 512 Kbytes/second

sampledso.byte_rate_perhour
Help:
random value in the range (0,1023), so avg value is 512 bytes/hour

sampledso.datasize
Help:
This metric returns the amount of memory in kilobytes allocated for the
data segment of the PMDA.

This is handy for tracing memory utilization (and leaks) in libpcp_pmda.

sampledso.secret.foo.bar.max.redirect
Full Help: Error: No PMCD agent for domain of request

sampledso.secret.foo.bar.three
Help:
Value 3.

sampledso.secret.foo.bar.four
Help:
Value 4.

sampledso.secret.foo.bar.grunt.five
Help:
Value 5.

sampledso.secret.foo.bar.grunt.snort.six
Help:
Value 6.

sampledso.secret.foo.bar.grunt.snort.huff.puff.seven
Help:
Value 7.

sampledso.secret.foo.one
Help:
Value 1.

sampledso.secret.foo.two
Help:
Value 2.

sampledso.secret.bar
Help:
Value "foo".

sampledso.long.one
Help:
1 as a 32-bit integer

sampledso.long.ten
Help:
10 as a 32-bit integer

sampledso.long.hundred
Help:
100 as a 32-bit integer

sampledso.long.million
Help:
1000000 as a 32-bit integer

sampledso.long.write_me
Help:
a 32-bit integer that can be modified

sampledso.long.bin
Help:
like sample.bin but type 32

sampledso.long.bin_ctr
Help:
like sample.bin but type 32, SEM_COUNTER and SPACE_KBYTE

sampledso.ulong.one
Help:
1 as a 32-bit unsigned integer

sampledso.ulong.ten
Help:
10 as a 32-bit unsigned integer

sampledso.ulong.hundred
Help:
100 as a 32-bit unsigned integer

sampledso.ulong.million
Help:
1000000 as a 32-bit unsigned integer

sampledso.ulong.write_me
Help:
a 32-bit unsigned integer that can be modified

sampledso.ulong.bin
Help:
like sample.bin but type U32

sampledso.ulong.bin_ctr
Help:
like sample.bin but type U32, SEM_COUNTER and SPACE_KBYTE

sampledso.ulong.count.base
Help:
count scale is 1, value is 42,000,000

sampledso.ulong.count.deca
Help:
count scale is 10, value is 4,200,000

sampledso.ulong.count.hecto
Help:
count scale is 10, value is 420,000

sampledso.ulong.count.kilo
Help:
count scale is 10, value is 42,000

sampledso.ulong.count.mega
Help:
count scale is 10, value is 42

sampledso.longlong.one
Help:
1 as a 64-bit integer

sampledso.longlong.ten
Help:
10 as a 64-bit integer

sampledso.longlong.hundred
Help:
100 as a 64-bit integer

sampledso.longlong.million
Help:
1000000 as a 64-bit integer

sampledso.longlong.write_me
Help:
a 64-bit integer that can be modified

sampledso.longlong.bin
Help:
like sample.bin but type 64

sampledso.longlong.bin_ctr
Help:
like sample.bin but type 64, SEM_COUNTER and SPACE_KBYTE

sampledso.ulonglong.one
Help:
1 as a 64-bit unsigned integer

sampledso.ulonglong.ten
Help:
10 as a 64-bit unsigned integer

sampledso.ulonglong.hundred
Help:
100 as a 64-bit unsigned integer

sampledso.ulonglong.million
Help:
1000000 as a 64-bit unsigned integer

sampledso.ulonglong.write_me
Help:
a 64-bit unsigned integer that can be modified

sampledso.ulonglong.bin
Help:
like sample.bin but type U64

sampledso.ulonglong.bin_ctr
Help:
like sample.bin but type U64, SEM_COUNTER and SPACE_KBYTE

sampledso.float.one
Help:
1 as a 32-bit floating point value

sampledso.float.ten
Help:
10 as a 32-bit floating point value

sampledso.float.hundred
Help:
100 as a 32-bit floating point value

sampledso.float.million
Help:
1000000 as a 32-bit floating point value

sampledso.float.write_me
Help:
a 32-bit floating-point value that can be modified

sampledso.float.bin
Help:
like sample.bin but type FLOAT

sampledso.float.bin_ctr
Help:
like sample.bin but type FLOAT, SEM_COUNTER and SPACE_KBYTE

sampledso.double.one
Help:
1 as a 64-bit floating point value

sampledso.double.ten
Help:
10 as a 64-bit floating point value

sampledso.double.hundred
Help:
100 as a 64-bit floating point value

sampledso.double.million
Help:
1000000 as a 64-bit floating point value

sampledso.double.write_me
Help:
a 64-bit floating-point value that can be modified

sampledso.double.bin
Help:
like sample.bin but type DOUBLE

sampledso.double.bin_ctr
Help:
like sample.bin but type DOUBLE, SEM_COUNTER and SPACE_KBYTE

sampledso.string.null
Help:
a zero length string

sampledso.string.hullo
Help:
K&R have a lot to answer for

sampledso.string.write_me
Help:
a string value that can be modified

sampledso.string.bin
Help:
a string-valued version of sample.bin

sampledso.aggregate.null
Help:
a zero length aggregate

sampledso.aggregate.hullo
Help:
K&R have a lot to answer for

sampledso.aggregate.write_me
Help:
a aggregate value that can be modified

sampledso.hordes.one
Help:
Value of the metric is the instance identifier.

sampledso.hordes.two
Help:
Value of the metric is 500 - the instance identifier.

sampledso.bad.unknown
Help:
In the PMNS, but the sampledso agent pretends it does not know about this one.

sampledso.bad.nosupport
Help:
Type is PM_NOSUPPORT, fetch returns PM_ERR_APPVERSION

sampledso.bad.novalues
Help:
Scalar with no values, ever

sampledso.bad.fetch.again
Help:
Fetch returns PM_ERR_AGAIN, always

sampledso.wrap.long
Help:
The metric value increments by INT_MAX / 2 - 1 (from <limits.h>) every
time it is fetched.

sampledso.wrap.ulong
Help:
The metric value increments by UINT_MAX / 2 - 1 (from <limits.h>) every
time it is fetched.

sampledso.wrap.longlong
Help:
The metric value increments by LONGLONG_MAX / 2 - 1 (from <limits.h>)
every time it is fetched.

sampledso.wrap.ulonglong
Help:
The metric value increments by ULONGLONG_MAX / 2 - 1 (from <limits.h>)
every time it is fetched.

sampledso.dodgey.control
Help:
If sampledso.dodgey.control is <= 0, then this is returned as the "numval"
component in the pmResult (0 => no values available, less than 0 =>
various errors).

If sampledso.dodgey.control is between 1 and 5 (inclusive), then this many
of the values will be "visible".  The values will be selected in order
from the underlying 5 instances.

If sampledso.dodgey.control is > 5, then at random times (between 1 and
sampledso.dodgey.control fetches of the metric), the number of instances
available is changed according to the following probabilities ...
  0.9 some number of instances in the range 0 to 5, selected at random
      from the underlying 5 instances.
  0.1 error (PM_ERR_NOAGENT or PM_ERR_AGAIN or PM_ERR_APPVERSION)

sampledso.dodgey.value
Help:
The metric is a set of 5 instantaneous values, drawn at random from the
range 0 to 100.  The number of instances "visible" is controlled by
sampledso.dodgey.control.

sampledso.dynamic.counter
Help:
Instances come from $PCP_PMDAS_DIR/sampledso/dynamic.indom, if it exists.
Each line in this file is
	internal_id external_id

This metric increments each time this instance has been seen when scanning
the dynamic.indom file, and resets to zero each time the instance appears.

sampledso.dynamic.discrete
Help:
Instances come from $PCP_PMDAS_DIR/sampledso/dynamic.indom, if it exists.
Each line in this file is
	internal_id external_id

This metric increments each time this instance has been seen when scanning
the dynamic.indom file, and resets to zero each time the instance appears.

sampledso.dynamic.instant
Help:
Instances come from $PCP_PMDAS_DIR/sampledso/dynamic.indom, if it exists.
Each line in this file is
	internal_id external_id

This metric increments each time this instance has been seen when scanning
the dynamic.indom file, and resets to zero each time the instance appears.

sampledso.dynamic.meta.metric
Help:
See sampledso.dynamic.meta.pmdesc for the metrics that can be modified to
change the metadata for this metric.
The value of this metric is always 42.

sampledso.dynamic.meta.pmdesc.type
Help:
One of these values:
PM_TYPE_NOSUPPORT       -1      /* not implemented in this version */
PM_TYPE_32              0       /* 32-bit signed integer */
PM_TYPE_U32             1       /* 32-bit unsigned integer */
PM_TYPE_64              2       /* 64-bit signed integer */
PM_TYPE_U64             3       /* 64-bit unsigned integer */
PM_TYPE_FLOAT           4       /* 32-bit floating point */
PM_TYPE_DOUBLE          5       /* 64-bit floating point */
PM_TYPE_STRING          6       /* array of char */
PM_TYPE_AGGREGATE       7       /* arbitrary binary data (aggregate) */
PM_TYPE_AGGREGATE_STATIC 8      /* static pointer to aggregate */
PM_TYPE_UNKNOWN         255     /* used in pmValueBlock, not pmDesc */

Defaults to PM_TYPE_32.

sampledso.dynamic.meta.pmdesc.indom
Help:
Defaults to PM_INDOM_NULL (0xffffffff).

sampledso.dynamic.meta.pmdesc.sem
Help:
One of these values:
PM_SEM_COUNTER  1       /* cumulative counter (monotonic increasing) */
PM_SEM_INSTANT  3       /* instantaneous value, continuous domain */
PM_SEM_DISCRETE 4       /* instantaneous value, discrete domain */

Defaults to PM_SEM_DISCRETE.

sampledso.dynamic.meta.pmdesc.units
Help:
6 x 4-bit values, from least-significant bit to most-significant bit:
dimSpace:
   -1, 0, 1
dimTime:
   -1, 0, 1
dimCount:
   0, 1
scaleSpace:
    PM_SPACE_BYTE   0       /* bytes */
    PM_SPACE_KBYTE  1       /* Kilobytes (1024) */
    PM_SPACE_MBYTE  2       /* Megabytes (1024^2) */
    PM_SPACE_GBYTE  3       /* Gigabytes (1024^3) */
    PM_SPACE_TBYTE  4       /* Terabytes (1024^4) */
    PM_SPACE_PBYTE  5       /* Petabytes (1024^5) */
    PM_SPACE_EBYTE  6       /* Exabytes  (1024^6) */
scaleTime:
    PM_TIME_NSEC    0       /* nanoseconds */
    PM_TIME_USEC    1       /* microseconds */
    PM_TIME_MSEC    2       /* milliseconds */
    PM_TIME_SEC     3       /* seconds */
    PM_TIME_MIN     4       /* minutes */
    PM_TIME_HOUR    5       /* hours */
scaleCount:
    PM_COUNT_ONE    0       /* 1 */

Defaults to { 1, -1, 0, PM_SPACE_BYTE, PM_TIME_SEC, 0 }

sampledso.scale_step.bytes_up
Help:
count up by powers of 2, wrap back to one at 10 Tbytes

sampledso.scale_step.bytes_down
Help:
count down by powers of 2, wrap back to 10 Tbytes at 1

sampledso.scale_step.count_up
Help:
count up by powers of 10, wrap back to 1 at 10e12

sampledso.scale_step.count_down
Help:
count down by powers of 10, wrap back to 10e12 at 1

sampledso.scale_step.time_up_secs
Help:
count up seconds by multiples of 10, wrap back to 1 second at 1 day

sampledso.scale_step.time_up_nanosecs
Help:
count up nanoseconds by multiples of 10, wrap back to 1 nanosecond at 1 day

sampledso.scale_step.none_up
Help:
count up dimensionless by multiples of 10, wrap back to 1 at 10 million

sampledso.const_rate.value
Help:
A counter that changes with constant rate between fetches.

The rate is set by storing the desired rate (counts per second)
into sampledso.const_rate.gradient

sampledso.const_rate.gradient
Help:
rate per second to set sample.const_rate.value, writable

sampledso.many.count
Help:
store a value in sampledso.many.count to change the number of instances
that appear in sampledso.many.int's instance domain

sampledso.many.int
Help:
store a value in sampledso.many.count to change the number of instances
that appear in sampledso.many.int's instance domain

sampledso.scramble.version
Help:
To make the order of instances seen from sampledso.scramble.bin
deterministic, use pmstore(1) to trigger a reset.

sampledso.scramble.bin
Help:
Like sampledso.bin, except
1. instances are missing with probability 0.33
2. order of the instances from pmFetch is random

Designed to help testing instance matching between pmFetch calls
for PCP clients.

sampledso.percontext.pdu
Help:
Count of PDUs received from or transmitted to the current PMAPI client
context.

Use pmStore() to reset the counter to 0, independent of the value passed
to pmStore().

sampledso.percontext.recv_pdu
Help:
Count of PDUs received from the current PMAPI client context.

Use pmStore() to reset the counter to 0, independent of the value passed
to pmStore().

sampledso.percontext.xmit_pdu
Help:
Count of PDUs transmitted to the current PMAPI client context.

Use pmStore() to reset the counter to 0, independent of the value passed
to pmStore().

sampledso.percontext.control.ctx
Help:
One more than the highest PMAPI context number from PMCD.

sampledso.percontext.control.active
Help:
Number of active PMAPI contexts

sampledso.percontext.control.start
Help:
Incremented each time a new PMAPI context is seen from PMCD.

sampledso.percontext.control.start - sample.percontext.control.end
should equal sampledso.percontext.control.active.

sampledso.percontext.control.end
Help:
Incremented each time PMCD closes a PMAPI context.

sampledso.percontext.control.start - sample.percontext.control.end
should equal sampledso.percontext.control.active.

sampledso.event.records
Help:
Dummy event records are generated in a fixed pattern to help QA.

Once all setups have been returned, the cycle is repeated.

See event.reset to exert explicit control over the next batch of event
records to be returned.

sampledso.event.highres_records
Help:
Dummy high resolution event records generated in a fixed pattern to help QA.

Once all setups have been returned, the cycle is repeated.

See event.reset_highres to exert explicit control over the next batch of event
records to be returned.

sampledso.event.no_indom_records
Help:
Like sampledso.event.records but without the instance domain.

sampledso.event.reset
Help:
Used for QA, should take one of the values 0, 1, 2 or 3
to determine which of the dummy event record setups will
be returned for the next fetch of event.records.

sampledso.event.reset_highres
Help:
Used for QA, should take one of the values 0, 1, 2 or 3
to determine which of the dummy event record setups will
be returned for the next fetch of event.highres_records.

sampledso.event.type
Help:
event type parameter for event records

sampledso.event.param_32
Help:
32 parameter for event records

sampledso.event.param_u32
Help:
U32 parameter for event records

sampledso.event.param_64
Help:
64 parameter for event records

sampledso.event.param_u64
Help:
U64 parameter for event records

sampledso.event.param_float
Help:
FLOAT parameter for event records

sampledso.event.param_double
Help:
DOUBLE parameter for event records

sampledso.event.param_string
Help:
STRING parameter for event records

sampledso.event.param_aggregate
Help:
AGGREGATE parameter for event records

sampledso.dupnames.daemon_pid
Help:
The process id of PMDA daemon, -1 if the daemon is a DSO.

sampledso.dupnames.pid_daemon
Help:
The process id of PMDA daemon, -1 if the daemon is a DSO.

sampledso.dupnames.two.seconds
Help:
The elapsed time since the PMDA started, in seconds, i.e. as returned
by time(2).

sampledso.dupnames.two.bin
Help:
9 instances labelled "bin-100" thru "bin-900", each with an
initial value of 100 thru 900.

pmstore(1) may be used to change the values of some or all of
the instances, but note this will also change the values of the
metrics that share the same underlying values, i.e. sampledso.bucket,
sampledso.part_bin, sample.bogus_bin, sample.scramble.bin
sampledso.long.bin, sample.long.bin_ctr, sample.ulong.bin,
sampledso.ulong.bin_ctr, sample.longlong.bin, sample.longlong.bin_ctr,
sampledso.ulonglong.bin, sample.ulonglong.bin_ctr, sample.float.bin,
sampledso.float.bin_ctr, sample.double.bin, sample.double.bin_ctr
and sampledso.string.bin.

sampledso.dupnames.two.write_me
Help:
This metric has a 32-bit integer value of 2, unless changed via pmStore.
The metric has semantics of rate, and units of events per second.

sampledso.dupnames.two.lights
Help:
A singular metric that has a discrete string value, namely "red",
"yellow" or "green".  There is some persistance in the value, so
consecutive fetches are likely to return the same value, however over a
long period of time all values are equally probable.

sampledso.dupnames.two.float.ten
Help:
10 as a 32-bit floating point value

sampledso.dupnames.two.double.ten
Help:
10 as a 64-bit floating point value

sampledso.dupnames.three.bin
Help:
9 instances labelled "bin-100" thru "bin-900", each with an
initial value of 100 thru 900.

pmstore(1) may be used to change the values of some or all of
the instances, but note this will also change the values of the
metrics that share the same underlying values, i.e. sampledso.bucket,
sampledso.part_bin, sample.bogus_bin, sample.scramble.bin
sampledso.long.bin, sample.long.bin_ctr, sample.ulong.bin,
sampledso.ulong.bin_ctr, sample.longlong.bin, sample.longlong.bin_ctr,
sampledso.ulonglong.bin, sample.ulonglong.bin_ctr, sample.float.bin,
sampledso.float.bin_ctr, sample.double.bin, sample.double.bin_ctr
and sampledso.string.bin.

sampledso.dupnames.three.write_me
Help:
This metric has a 32-bit integer value of 2, unless changed via pmStore.
The metric has semantics of rate, and units of events per second.

sampledso.negative.ctr.m_32
Help:
A metric with the semantics of PM_SEM_COUNTER, a type of PM_TYPE_32
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_32 metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all
of the sampledso.negative.*.m_32 metrics (they share the same underlying
counter).

sampledso.negative.ctr.m_64
Help:
A metric with the semantics of PM_SEM_COUNTER, a type of PM_TYPE_64
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_64 metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all
of the sampledso.negative.*.m_64 metrics (they share the same underlying
counter).

sampledso.negative.ctr.m_float
Help:
A metric with the semantics of PM_SEM_COUNTER, a type of PM_TYPE_FLOAT
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_float metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all of
the sampledso.negative.*.m_float metrics (they share the same underlying
counter).

sampledso.negative.ctr.m_double
Help:
A metric with the semantics of PM_SEM_COUNTER, a type of PM_TYPE_DOUBLE
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_double metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all of
the sampledso.negative.*.m_double metrics (they share the same underlying
counter).

sampledso.negative.instant.m_32
Help:
A metric with the semantics of PM_SEM_INSTANT, a type of PM_TYPE_32
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_32 metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all
of the sampledso.negative.*.m_32 metrics (they share the same underlying
counter).

sampledso.negative.instant.m_64
Help:
A metric with the semantics of PM_SEM_INSTANT, a type of PM_TYPE_64
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_64 metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all
of the sampledso.negative.*.m_64 metrics (they share the same underlying
counter).

sampledso.negative.instant.m_float
Help:
A metric with the semantics of PM_SEM_INSTANT, a type of PM_TYPE_FLOAT
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_float metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all of
the sampledso.negative.*.m_float metrics (they share the same underlying
counter).

sampledso.negative.instant.m_double
Help:
A metric with the semantics of PM_SEM_INSTANT, a type of PM_TYPE_DOUBLE
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_double metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all of
the sampledso.negative.*.m_double metrics (they share the same underlying
counter).

sampledso.negative.discrete.m_32
Help:
A metric with the semantics of PM_SEM_DISCRETE, a type of PM_TYPE_32
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_32 metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all
of the sampledso.negative.*.m_32 metrics (they share the same underlying
counter).

sampledso.negative.discrete.m_64
Help:
A metric with the semantics of PM_SEM_DISCRETE, a type of PM_TYPE_64
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_64 metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all
of the sampledso.negative.*.m_64 metrics (they share the same underlying
counter).

sampledso.negative.discrete.m_float
Help:
A metric with the semantics of PM_SEM_DISCRETE, a type of PM_TYPE_FLOAT
and negative values that by default start at -10000 and are incremented
each time one of the sampledso.negative.*.m_float metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all of
the sampledso.negative.*.m_float metrics (they share the same underlying
counter).

sampledso.negative.discrete.m_double
Help:
A metric with the semantics of PM_SEM_DISCRETE, a type of
PM_TYPE_DOUBLE and negative values that by default start at -10000
and are incremented each time one of the sampledso.negative.*.m_double
metrics are fetched.

Maybe be reset with pmStore, but this will reset the value for all of
the sampledso.negative.*.m_double metrics (they share the same underlying
counter).
--- help.c case 3 ---

sample.seconds
Help:
The elapsed time since the PMDA started, in seconds, i.e. as returned
by time(2).

sample.colour
Help:
This metric has 3 instances, designated "red", "green" and "blue".

The value of the metric is monotonic increasing in the range N to
N+100, then back to N.  The different instances have different N
values, namely 100 (red), 200 (green) and 300 (blue).

The underlying counter starts at 0 and is incremented once
for each pmFetch() to this metric and/or sample.mirage and/or
sample.mirage_longlong.

Use pmStore() to modify the underlying counter (independent of which
instance or instances are used).

sample.bin
Help:
9 instances labelled "bin-100" thru "bin-900", each with an
initial value of 100 thru 900.

pmstore(1) may be used to change the values of some or all of
the instances, but note this will also change the values of the
metrics that share the same underlying values, i.e. sample.bucket,
sample.part_bin, sample.bogus_bin, sample.scramble.bin
sample.long.bin, sample.long.bin_ctr, sample.ulong.bin,
sample.ulong.bin_ctr, sample.longlong.bin, sample.longlong.bin_ctr,
sample.ulonglong.bin, sample.ulonglong.bin_ctr, sample.float.bin,
sample.float.bin_ctr, sample.double.bin, sample.double.bin_ctr
and sample.string.bin.

sample.drift
Help:
This metric returns a random value (expected mean is approximately 200),
subject to a trending pattern such that the sequence is mainly monotonic,
with a change in direction after on average 4 consecutive samples.

Use pmStore() to modify the instantaneous value, which becomes the new
expected mean.

sample.lights
Help:
A singular metric that has a discrete string value, namely "red",
"yellow" or "green".  There is some persistance in the value, so
consecutive fetches are likely to return the same value, however over a
long period of time all values are equally probable.

sample.dupnames.three.bin
Help:
9 instances labelled "bin-100" thru "bin-900", each with an
initial value of 100 thru 900.

pmstore(1) may be used to change the values of some or all of
the instances, but note this will also change the values of the
metrics that share the same underlying values, i.e. sample.bucket,
sample.part_bin, sample.bogus_bin, sample.scramble.bin
sample.long.bin, sample.long.bin_ctr, sample.ulong.bin,
sample.ulong.bin_ctr, sample.longlong.bin, sample.longlong.bin_ctr,
sample.ulonglong.bin, sample.ulonglong.bin_ctr, sample.float.bin,
sample.float.bin_ctr, sample.double.bin, sample.double.bin_ctr
and sample.string.bin.

sample.dupnames.two.seconds
Help:
The elapsed time since the PMDA started, in seconds, i.e. as returned
by time(2).

sample.dupnames.two.bin
Help:
9 instances labelled "bin-100" thru "bin-900", each with an
initial value of 100 thru 900.

pmstore(1) may be used to change the values of some or all of
the instances, but note this will also change the values of the
metrics that share the same underlying values, i.e. sample.bucket,
sample.part_bin, sample.bogus_bin, sample.scramble.bin
sample.long.bin, sample.long.bin_ctr, sample.ulong.bin,
sample.ulong.bin_ctr, sample.longlong.bin, sample.longlong.bin_ctr,
sample.ulonglong.bin, sample.ulonglong.bin_ctr, sample.float.bin,
sample.float.bin_ctr, sample.double.bin, sample.double.bin_ctr
and sample.string.bin.

sample.dupnames.two.lights
Help:
A singular metric that has a discrete string value, namely "red",
"yellow" or "green".  There is some persistance in the value, so
consecutive fetches are likely to return the same value, however over a
long period of time all values are equally probable.
--- help.c case 4 ---

simple.now
Help:
The value reflects the current time of day through a dynamically
reconfigurable instance domain.  On each metric value fetch request,
the agent checks to see whether the configuration file in
$PCP_PMDAS_DIR/simple/simple.conf has been modified - if it has then
the file is re-parsed and the instance domain for this metric is again
constructed according to its contents.

This configuration file contains a single line of comma-separated time
tokens from this set:
  "sec"  (seconds after the minute),
  "min"  (minutes after the hour),
  "hour" (hour since midnight).

An example configuration file could be:  sec,min,hour
and in this case the simple.now metric would export values
for the three instances "sec", "min" and "hour" corresponding
respectively to the components seconds, minutes and hours of the
current time of day.

The instance domain reflects each token present in the file, and the
values reflect the time at which the PMDA processes the fetch.
--- instance.c case 1 ---
__pmFetchLocal: calling ???_profile(domain: 30), context: 0
__pmFetchLocal: [0] PMID=30.0.6 nval=9
pmFetch returns ...
pmResult ... numpmid: 1
  30.0.6 (sampledso.dupnames.three.bin, sampledso.dupnames.two.bin, sampledso.bin): numval: 9 valfmt: 0 vlist[]:
    inst [100 or "bin-100"] value NUMBER
    inst [200 or "bin-200"] value NUMBER
    inst [300 or "bin-300"] value NUMBER
    inst [400 or "bin-400"] value NUMBER
    inst [500 or "bin-500"] value NUMBER
    inst [600 or "bin-600"] value NUMBER
    inst [700 or "bin-700"] value NUMBER
    inst [800 or "bin-800"] value NUMBER
    inst [900 or "bin-900"] value NUMBER

sampledso.bin
    inst [100 or "bin-100"] value NUMBER
    inst [200 or "bin-200"] value NUMBER
    inst [300 or "bin-300"] value NUMBER
    inst [400 or "bin-400"] value NUMBER
    inst [500 or "bin-500"] value NUMBER
    inst [600 or "bin-600"] value NUMBER
    inst [700 or "bin-700"] value NUMBER
    inst [800 or "bin-800"] value NUMBER
    inst [900 or "bin-900"] value NUMBER
--- instance.c case 2 ---
pmInResult dump from HEX for InDom 29.2 (HEX), numinst=9
  [0] inst=100 name="bin-100"
  [1] inst=200 name="bin-200"
  [2] inst=300 name="bin-300"
  [3] inst=400 name="bin-400"
  [4] inst=500 name="bin-500"
  [5] inst=600 name="bin-600"
  [6] inst=700 name="bin-700"
  [7] inst=800 name="bin-800"
  [8] inst=900 name="bin-900"

sample.bin
    inst [100 or "bin-100"] value 100
    inst [200 or "bin-200"] value 200
    inst [300 or "bin-300"] value 300
    inst [400 or "bin-400"] value 400
    inst [500 or "bin-500"] value 500
    inst [600 or "bin-600"] value 600
    inst [700 or "bin-700"] value 700
    inst [800 or "bin-800"] value 800
    inst [900 or "bin-900"] value 900
--- instance.c case 3 ---
__pmFetchLocal: calling ???_profile(domain: 253), context: 0
__pmdaStartInst(indom=253.0) e_ordinal=0
__pmdaNextInst(indom=253.0) -> 0 e_ordinal=1
__pmdaNextInst(indom=253.0) -> 1 e_ordinal=2
__pmdaNextInst(indom=253.0) -> 2 e_ordinal=3
__pmdaStartInst(indom=253.0) e_ordinal=0
__pmdaNextInst(indom=253.0) -> 0 e_ordinal=1
__pmdaNextInst(indom=253.0) -> 1 e_ordinal=2
__pmdaNextInst(indom=253.0) -> 2 e_ordinal=3
__pmdaStartInst(indom=253.1) e_ordinal=0
__pmdaNextInst(indom=253.1) -> 0 e_ordinal=1 (cache)
__pmdaNextInst(indom=253.1) -> 1 e_ordinal=2 (cache)
__pmdaNextInst(indom=253.1) -> 2 e_ordinal=3 (cache)
__pmdaStartInst(indom=253.1) e_ordinal=0
__pmdaNextInst(indom=253.1) -> 0 e_ordinal=1 (cache)
__pmdaNextInst(indom=253.1) -> 1 e_ordinal=2 (cache)
__pmdaNextInst(indom=253.1) -> 2 e_ordinal=3 (cache)
__pmFetchLocal: [0] PMID=253.0.0 nval=1
__pmFetchLocal: [1] PMID=253.0.1 nval=3
__pmFetchLocal: [2] PMID=253.1.2 nval=1
__pmFetchLocal: [3] PMID=253.1.3 nval=1
__pmFetchLocal: [4] PMID=253.2.4 nval=3
pmFetch returns ...
pmResult ... numpmid: 5
  253.0.0 (simple.numfetch): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  253.0.1 (simple.color): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "red"] value NUMBER
    inst [1 or "green"] value NUMBER
    inst [2 or "blue"] value NUMBER
  253.1.2 (simple.time.user): numval: 1 valfmt: 1 vlist[]:
   value NUMBER
  253.1.3 (simple.time.sys): numval: 1 valfmt: 1 vlist[]:
   value NUMBER
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
__pmdaCntInst(indom=253.0) -> 3
__pmdaCntInst(indom=253.1) -> 3

simple.numfetch
    value NUMBER

simple.color
    inst [0 or "red"] value NUMBER
    inst [1 or "green"] value NUMBER
    inst [2 or "blue"] value NUMBER

simple.time.user
    value NUMBER

simple.time.sys
    value NUMBER

simple.now
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
--- instance.c case 4 ---
sample.bin:
pm*InDom: inst=[0] {Unknown or illegal instance identifier}
pmGetInDom:
--- instance.c case 5 ---
sample.long.one:
pm*InDom: inst=[0] {Unknown or illegal instance domain identifier}
pmGetInDom: {Unknown or illegal instance domain identifier}
Error: Unknown or illegal instance domain identifier
--- instance.c case 6 ---
pmval: instance bin-123 not available
--- instance.c case 7 (expect not output) ---
--- instance.c case 8 (expect not output) ---
--- fetchlocal.c case 1 ---
__pmFetchLocal: calling ???_profile(domain: 30), context: 0
__pmFetchLocal: [0] PMID=30.0.54 nval=Unknown or illegal metric identifier
pmFetch returns ...
pmResult ... numpmid: 1
  30.0.54 (sampledso.bad.unknown): Unknown or illegal metric identifier
sampledso.bad.unknown: pmLookupDesc: Unknown or illegal metric identifier
--- spec.c case 1 ---

sample.long.hundred
    value 100
--- spec.c case 2 ---

sample.long.hundred
    value 100
--- spec.c case 3 ---
pmNewContext: bad host specification
localhost:
          ^ -- missing port
pminfo: Cannot connect to PMCD on host "localhost:": Generic error, already reported above
--- spec.c case 4 ---
pmNewContext: bad host specification
localhost:44321,1x3
                 ^ -- non-numeric port
pminfo: Cannot connect to PMCD on host "localhost:44321,1x3": Generic error, already reported above
--- spec.c case 5 ---
pminfo: Cannot connect to PMCD on host "localhost:44321@no-host": No route to host
--- spec.c case 6 ---
pminfo: Cannot connect to PMCD on host "localhost:44321@no-host:44322": No route to host
--- spec.c case 7 ---
pminfo: Cannot connect to PMCD on host "localhost:44321@": No route to host
--- units.c case 1 (expect not output) ---
--- units.c case 2 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: Pbyte / hour
--- units.c case 3 (expect not output) ---
--- units.c case 4 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: Ebyte / sec
--- units.c case 5 (expect not output) ---
--- units.c case 6 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: Zbyte
--- units.c case 7 (expect not output) ---
--- units.c case 8 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: time-6
--- units.c case 9 (expect not output) ---
--- units.c case 10 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: byte^2
--- units.c case 11 (expect not output) ---
--- units.c case 12 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: nanosec / byte
--- units.c case 13 (expect not output) ---
--- units.c case 14 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: / byte^2
--- units.c case 15 (expect not output) ---
--- units.c case 16 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: nanosec^3
--- units.c case 17 (expect not output) ---
--- units.c case 18 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: / nanosec^3
--- units.c case 19 (expect not output) ---
--- units.c case 20 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: count^2
--- units.c case 21 (expect not output) ---
--- units.c case 22 ---

sample.dynamic.meta.metric
    Data Type: 32-bit int  InDom: PM_INDOM_NULL 0xffffffff
    Semantics: discrete  Units: / count^2
--- units.c case 23 (expect not output) ---
--- units.c case 24 type=0 ---
type=0 input units=Tbyte value=1024
output units=Gbyte value=1048576
--- units.c case 25 type=0 ---
type=0 input units=Gbyte value=1048576
output units=Tbyte value=1024
--- units.c case 26 type=0 ---
type=0 input units=Mbyte / sec value=4096
output units=Gbyte / hour value=14400
--- units.c case 27 type=0 ---
type=0 input units=Gbyte / hour value=14400
output units=Mbyte / sec value=4096
--- units.c case 28 type=0 ---
type=0 input units=Kbyte sec / count value=92160
output units=Mbyte min / count x 10 value=15
--- units.c case 29 type=0 ---
type=0 input units=Mbyte min / count x 10 value=15
output units=Kbyte sec / count value=92160
--- units.c case 30 type=0 ---
type=0 input units=sec / Mbyte value=1024
output units=millisec / Kbyte value=1000
--- units.c case 31 type=0 ---
type=0 input units=millisec / Kbyte value=1000
output units=sec / Mbyte value=1024
--- units.c case 24 type=1 ---
type=1 input units=Tbyte value=1024
output units=Gbyte value=1048576
--- units.c case 25 type=1 ---
type=1 input units=Gbyte value=1048576
output units=Tbyte value=1024
--- units.c case 26 type=1 ---
type=1 input units=Mbyte / sec value=4096
output units=Gbyte / hour value=14400
--- units.c case 27 type=1 ---
type=1 input units=Gbyte / hour value=14400
output units=Mbyte / sec value=4096
--- units.c case 28 type=1 ---
type=1 input units=Kbyte sec / count value=92160
output units=Mbyte min / count x 10 value=15
--- units.c case 29 type=1 ---
type=1 input units=Mbyte min / count x 10 value=15
output units=Kbyte sec / count value=92160
--- units.c case 30 type=1 ---
type=1 input units=sec / Mbyte value=1024
output units=millisec / Kbyte value=1000
--- units.c case 31 type=1 ---
type=1 input units=millisec / Kbyte value=1000
output units=sec / Mbyte value=1024
--- units.c case 24 type=2 ---
type=2 input units=Tbyte value=1024
output units=Gbyte value=1048576
--- units.c case 25 type=2 ---
type=2 input units=Gbyte value=1048576
output units=Tbyte value=1024
--- units.c case 26 type=2 ---
type=2 input units=Mbyte / sec value=4096
output units=Gbyte / hour value=14400
--- units.c case 27 type=2 ---
type=2 input units=Gbyte / hour value=14400
output units=Mbyte / sec value=4096
--- units.c case 28 type=2 ---
type=2 input units=Kbyte sec / count value=92160
output units=Mbyte min / count x 10 value=15
--- units.c case 29 type=2 ---
type=2 input units=Mbyte min / count x 10 value=15
output units=Kbyte sec / count value=92160
--- units.c case 30 type=2 ---
type=2 input units=sec / Mbyte value=1024
output units=millisec / Kbyte value=1000
--- units.c case 31 type=2 ---
type=2 input units=millisec / Kbyte value=1000
output units=sec / Mbyte value=1024
--- units.c case 24 type=3 ---
type=3 input units=Tbyte value=1024
output units=Gbyte value=1048576
--- units.c case 25 type=3 ---
type=3 input units=Gbyte value=1048576
output units=Tbyte value=1024
--- units.c case 26 type=3 ---
type=3 input units=Mbyte / sec value=4096
output units=Gbyte / hour value=14400
--- units.c case 27 type=3 ---
type=3 input units=Gbyte / hour value=14400
output units=Mbyte / sec value=4096
--- units.c case 28 type=3 ---
type=3 input units=Kbyte sec / count value=92160
output units=Mbyte min / count x 10 value=15
--- units.c case 29 type=3 ---
type=3 input units=Mbyte min / count x 10 value=15
output units=Kbyte sec / count value=92160
--- units.c case 30 type=3 ---
type=3 input units=sec / Mbyte value=1024
output units=millisec / Kbyte value=1000
--- units.c case 31 type=3 ---
type=3 input units=millisec / Kbyte value=1000
output units=sec / Mbyte value=1024
--- units.c case 24 type=4 ---
type=4 input units=Tbyte value=1.024000e+03
output units=Gbyte value=1.048576e+06
--- units.c case 25 type=4 ---
type=4 input units=Gbyte value=1.048576e+06
output units=Tbyte value=1.024000e+03
--- units.c case 26 type=4 ---
type=4 input units=Mbyte / sec value=4.096000e+03
output units=Gbyte / hour value=1.440000e+04
--- units.c case 27 type=4 ---
type=4 input units=Gbyte / hour value=1.440000e+04
output units=Mbyte / sec value=4.096000e+03
--- units.c case 28 type=4 ---
type=4 input units=Kbyte sec / count value=9.216000e+04
output units=Mbyte min / count x 10 value=1.500000e+01
--- units.c case 29 type=4 ---
type=4 input units=Mbyte min / count x 10 value=1.500000e+01
output units=Kbyte sec / count value=9.216000e+04
--- units.c case 30 type=4 ---
type=4 input units=sec / Mbyte value=1.024000e+03
output units=millisec / Kbyte value=1.000000e+03
--- units.c case 31 type=4 ---
type=4 input units=millisec / Kbyte value=1.000000e+03
output units=sec / Mbyte value=1.024000e+03
--- units.c case 24 type=5 ---
type=5 input units=Tbyte value=1.024000e+03
output units=Gbyte value=1.048576e+06
--- units.c case 25 type=5 ---
type=5 input units=Gbyte value=1.048576e+06
output units=Tbyte value=1.024000e+03
--- units.c case 26 type=5 ---
type=5 input units=Mbyte / sec value=4.096000e+03
output units=Gbyte / hour value=1.440000e+04
--- units.c case 27 type=5 ---
type=5 input units=Gbyte / hour value=1.440000e+04
output units=Mbyte / sec value=4.096000e+03
--- units.c case 28 type=5 ---
type=5 input units=Kbyte sec / count value=9.216000e+04
output units=Mbyte min / count x 10 value=1.500000e+01
--- units.c case 29 type=5 ---
type=5 input units=Mbyte min / count x 10 value=1.500000e+01
output units=Kbyte sec / count value=9.216000e+04
--- units.c case 30 type=5 ---
type=5 input units=sec / Mbyte value=1.024000e+03
output units=millisec / Kbyte value=1.000000e+03
--- units.c case 31 type=5 ---
type=5 input units=millisec / Kbyte value=1.000000e+03
output units=sec / Mbyte value=1.024000e+03
--- units.c case 41 ---
pmConvScale: 4096 [Pbyte] -> 4 [Ebyte]
type=3 input units=Pbyte value=4096
output units=Ebyte value=4
--- units.c case 42 ---
type=3 input units=Ebyte value=4
output units=Pbyte value=4096
--- units.c error case 43 ---
type=3 input units=Zbyte value=4096
pmConvScale Error: Illegal pmUnits specification
--- units.c error case 44 ---
type=3 input units=Pbyte value=4096
pmConvScale Error: Illegal pmUnits specification
--- units.c error case 45 ---
type=3 input units=time-6 value=3600
pmConvScale Error: Illegal pmUnits specification
--- units.c error case 46 ---
pmConvScale: 3600 [min] -> Error: Illegal pmUnits specification [time-6]
type=3 input units=min value=3600
pmConvScale Error: Illegal pmUnits specification
--- units.c error case 47 ---
type=3 input units=microsec value=0
pmConvScale Error: Impossible value or scale conversion
--- units.c error case 48 ---
type=8 input units=microsec value=[type=AGGREGATE_STATIC len=1] 30
pmConvScale Error: Impossible value or scale conversion

--- units.c case 32 ---
pmExtractValue:  1073741823 [32] -> 1073741823 [32]
pmExtractValue:  1073741823 [32] -> 1073741823 [U32]
pmExtractValue:  1073741823 [32] -> 1073741823 [64]
pmExtractValue:  1073741823 [32] -> 1073741823 [U64]
pmExtractValue:  1073741823 [32] -> 1.073742e+09 [FLOAT]
pmExtractValue:  1073741823 [32] -> 1.073742e+09 [DOUBLE]
pmExtractValue:  1073741823 [32] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  1073741823 [32] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  1073741823 [32] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  1073741823 [32] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  1073741823 [U32] -> 1073741823 [32]
pmExtractValue:  1073741823 [U32] -> 1073741823 [U32]
pmExtractValue:  1073741823 [U32] -> 1073741823 [64]
pmExtractValue:  1073741823 [U32] -> 1073741823 [U64]
pmExtractValue:  1073741823 [U32] -> 1.073742e+09 [FLOAT]
pmExtractValue:  1073741823 [U32] -> 1.073742e+09 [DOUBLE]
pmExtractValue:  1073741823 [U32] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  1073741823 [U32] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  1073741823 [U32] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  1073741823 [U32] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  1073741823 [64] -> 1073741823 [32]
pmExtractValue:  1073741823 [64] -> 1073741823 [U32]
pmExtractValue:  1073741823 [64] -> 1073741823 [64]
pmExtractValue:  1073741823 [64] -> 1073741823 [U64]
pmExtractValue:  1073741823 [64] -> 1.073742e+09 [FLOAT]
pmExtractValue:  1073741823 [64] -> 1.073742e+09 [DOUBLE]
pmExtractValue:  1073741823 [64] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  1073741823 [64] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  1073741823 [64] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  1073741823 [64] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  1073741823 [U64] -> 1073741823 [32]
pmExtractValue:  1073741823 [U64] -> 1073741823 [U32]
pmExtractValue:  1073741823 [U64] -> 1073741823 [64]
pmExtractValue:  1073741823 [U64] -> 1073741823 [U64]
pmExtractValue:  1073741823 [U64] -> 1.073742e+09 [FLOAT]
pmExtractValue:  1073741823 [U64] -> 1.073742e+09 [DOUBLE]
pmExtractValue:  1073741823 [U64] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  1073741823 [U64] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  1073741823 [U64] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  1073741823 [U64] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  1.073742e+09 [FLOAT] -> 1073741824 [32]
pmExtractValue:  1.073742e+09 [FLOAT] -> 1073741824 [U32]
pmExtractValue:  1.073742e+09 [FLOAT] -> 1073741824 [64]
pmExtractValue:  1.073742e+09 [FLOAT] -> 1073741824 [U64]
pmExtractValue:  1.073742e+09 [FLOAT] -> 1.073742e+09 [FLOAT]
pmExtractValue:  1.073742e+09 [FLOAT] -> 1.073742e+09 [DOUBLE]
pmExtractValue:  1.073742e+09 [FLOAT] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  1.073742e+09 [FLOAT] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  1.073742e+09 [FLOAT] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  1.073742e+09 [FLOAT] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  1.073742e+09 [DOUBLE] -> 1073741823 [32]
pmExtractValue:  1.073742e+09 [DOUBLE] -> 1073741823 [U32]
pmExtractValue:  1.073742e+09 [DOUBLE] -> 1073741823 [64]
pmExtractValue:  1.073742e+09 [DOUBLE] -> 1073741823 [U64]
pmExtractValue:  1.073742e+09 [DOUBLE] -> 1.073742e+09 [FLOAT]
pmExtractValue:  1.073742e+09 [DOUBLE] -> 1.073742e+09 [DOUBLE]
pmExtractValue:  1.073742e+09 [DOUBLE] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  1.073742e+09 [DOUBLE] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  1.073742e+09 [DOUBLE] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  1.073742e+09 [DOUBLE] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [32]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [U32]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [64]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [U64]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [FLOAT]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [DOUBLE]
pmExtractValue:  "1073741823" [STRING] -> "1073741823" [STRING]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  "1073741823" [STRING] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [32]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [U32]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [64]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [U64]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [FLOAT]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [DOUBLE]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> [type=AGGREGATE len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  [len=12] 3ffffffe 3fffffff 40000000 [AGGREGATE] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [32]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [U32]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [64]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [U64]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [FLOAT]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [DOUBLE]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  ??? [EVENT] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [32]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [U32]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [64]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [U64]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [FLOAT]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [DOUBLE]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [STRING]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [AGGREGATE]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [EVENT]
pmExtractValue:  ??? [HIGHRES_EVENT] -> Error: Impossible value or scale conversion [HIGHRES_EVENT]

Value: 1073741823 0x000000003fffffff
--- units.c case 33 ---

Value: 2147483647 0x000000007fffffff
(float) 2.147484e+09 => (long) : Truncation in value conversion
(double) 2.147484e+09 => (long) : Truncation in value conversion
--- units.c case 34 ---

Value: 4294967295 0x00000000ffffffff
(long) -1 => (ulong) : Negative value in conversion to unsigned
(long) -1 => (ulonglong) : Negative value in conversion to unsigned
(ulong) 4294967295 => (long) : Truncation in value conversion
(longlong) 4294967295 => (long) : Truncation in value conversion
(ulonglong) 4294967295 => (long) : Truncation in value conversion
(float) 4.294967e+09 => (long) : Truncation in value conversion
(float) 4.294967e+09 => (ulong) : Truncation in value conversion
(double) 4.294967e+09 => (long) : Truncation in value conversion
(double) 4.294967e+09 => (ulong) : Truncation in value conversion
--- units.c case 35 ---

Value: 4611686018427387903 0x3fffffffffffffff
(long) -1 => (ulong) : Negative value in conversion to unsigned
(long) -1 => (ulonglong) : Negative value in conversion to unsigned
(ulong) 4294967295 => (long) : Truncation in value conversion
(longlong) 4611686018427387903 => (long) : Truncation in value conversion
(longlong) 4611686018427387903 => (ulong) : Truncation in value conversion
(ulonglong) 4611686018427387903 => (long) : Truncation in value conversion
(ulonglong) 4611686018427387903 => (ulong) : Truncation in value conversion
(float) 4.611686e+18 => (long) : Truncation in value conversion
(float) 4.611686e+18 => (ulong) : Truncation in value conversion
(double) 4.611686e+18 => (long) : Truncation in value conversion
(double) 4.611686e+18 => (ulong) : Truncation in value conversion
--- units.c case 36 ---

Value: 9223372036854775807 0x7fffffffffffffff
(long) -1 => (ulong) : Negative value in conversion to unsigned
(long) -1 => (ulonglong) : Negative value in conversion to unsigned
(ulong) 4294967295 => (long) : Truncation in value conversion
(longlong) 9223372036854775807 => (long) : Truncation in value conversion
(longlong) 9223372036854775807 => (ulong) : Truncation in value conversion
(ulonglong) 9223372036854775807 => (long) : Truncation in value conversion
(ulonglong) 9223372036854775807 => (ulong) : Truncation in value conversion
(float) 9.223372e+18 => (long) : Truncation in value conversion
(float) 9.223372e+18 => (ulong) : Truncation in value conversion
(float) 9.223372e+18 => (longlong) : Truncation in value conversion
(double) 9.223372e+18 => (long) : Truncation in value conversion
(double) 9.223372e+18 => (ulong) : Truncation in value conversion
(double) 9.223372e+18 => (longlong) : Truncation in value conversion
--- units.c case 37 ---

Value: -1 0xffffffffffffffff
(long) -1 => (ulong) : Negative value in conversion to unsigned
(long) -1 => (ulonglong) : Negative value in conversion to unsigned
(ulong) 4294967295 => (long) : Truncation in value conversion
(longlong) -1 => (ulong) : Negative value in conversion to unsigned
(longlong) -1 => (ulonglong) : Negative value in conversion to unsigned
(ulonglong) 18446744073709551615 => (long) : Truncation in value conversion
(ulonglong) 18446744073709551615 => (ulong) : Truncation in value conversion
(ulonglong) 18446744073709551615 => (longlong) : Truncation in value conversion
(float) -1.000000e+00 => (ulong) : Negative value in conversion to unsigned
(float) -1.000000e+00 => (ulonglong) : Negative value in conversion to unsigned
(double) -1.000000e+00 => (ulong) : Negative value in conversion to unsigned
(double) -1.000000e+00 => (ulonglong) : Negative value in conversion to unsigned
--- units.c case 38 ---

Value: 18446744073709551615 0xffffffffffffffff
(long) -1 => (ulong) : Negative value in conversion to unsigned
(long) -1 => (ulonglong) : Negative value in conversion to unsigned
(ulong) 4294967295 => (long) : Truncation in value conversion
(longlong) -1 => (ulong) : Negative value in conversion to unsigned
(longlong) -1 => (ulonglong) : Negative value in conversion to unsigned
(ulonglong) 18446744073709551615 => (long) : Truncation in value conversion
(ulonglong) 18446744073709551615 => (ulong) : Truncation in value conversion
(ulonglong) 18446744073709551615 => (longlong) : Truncation in value conversion
(float) 1.844674e+19 => (long) : Truncation in value conversion
(float) 1.844674e+19 => (ulong) : Truncation in value conversion
(float) 1.844674e+19 => (longlong) : Truncation in value conversion
(float) 1.844674e+19 => (ulonglong) : Truncation in value conversion
(double) 1.844674e+19 => (long) : Truncation in value conversion
(double) 1.844674e+19 => (ulong) : Truncation in value conversion
(double) 1.844674e+19 => (longlong) : Truncation in value conversion
(double) 1.844674e+19 => (ulonglong) : Truncation in value conversion
--- units.c case 39 ---
old FLOAT:         123.456 -> 32: 123
old FLOAT:  4151801600.000 -> 32: Truncation in value conversion
old FLOAT:         123.456 -> U32: 123
old FLOAT:  4294967296.000 -> U32: Truncation in value conversion
old FLOAT:        -123.456 -> U32: Negative value in conversion to unsigned
old FLOAT:         123.456 -> 64: 123
old FLOAT:  9223372036854775808.0 -> 64: Truncation in value conversion
old FLOAT:         123.456 -> U64: 123
old FLOAT: 18446744073709551616.0 -> U64: Truncation in value conversion
old FLOAT:        -123.456 -> U64: Negative value in conversion to unsigned
old FLOAT:       123.45678 -> DOUBLE:       123.45678
old FLOAT:       123.45678 -> STRING: Impossible value or scale conversion
bad 64:        12345 -> 64: Impossible value or scale conversion
bad U64:        12345 -> U64: Impossible value or scale conversion
bad FLOAT:         123.456 -> FLOAT: Impossible value or scale conversion
bad DOUBLE:         123.456 -> DOUBLE: Impossible value or scale conversion
bad STRING: not me -> STRING: Impossible value or scale conversion
bad AGGREGATE: len=0 -> AGGREGATE: Impossible value or scale conversion
--- store.c case 1 ---
pmResult ... numpmid: 3
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.97 (sampledso.ulong.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.24 (sampledso.longlong.write_me): numval: 1 valfmt: 1 vlist[]:
   value NUMBER

base store test (failures not unexpected) ...
pmStore: OK

numpmid == 0 tests (failures expected) ...
pmResult ... numpmid: 0
pmStore: Insufficient elements in list
__pmControlLog: Insufficient elements in list

numval == 0 tests (failures expected) ...
pmResult ... numpmid: 3
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.97 (sampledso.ulong.write_me): No values returned!
  30.0.24 (sampledso.longlong.write_me): numval: 1 valfmt: 1 vlist[]:
   value NUMBER
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.97 (sampledso.ulong.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.24 (sampledso.longlong.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER

numval < 0 tests (failures expected) ...
pmResult ... numpmid: 3
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.97 (sampledso.ulong.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.24 (sampledso.longlong.write_me): No PMCD agent for domain of request
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.97 (sampledso.ulong.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.24 (sampledso.longlong.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
Quitting need at least 4 metrics for profile tests
--- store.c case 2 ---
build_dsotab:  parsing ...
pmNewContext(3, localhost) -> 0
Dump Contexts: current -> contexts[0] handle 0
contexts[0] handle 0: standalone: profile=NOT_SENT
Dump Instance Profile state=INCLUDE, 0 profiles
__pmConnectLogger(host=localhost, pid=0, port=-2)
__pmConnectLogger: __pmLogFindPort -> pid = PID
__pmDecodeError: got error PDU (code=2, fromversion=2)
__pmSetVersionIPC: fd=N version=2
__pmSendCreds: ...
__pmConnectLogger: PDU version=2 fd=N
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): No PMCD agent for domain of request
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): No PMCD agent for domain of request

base store test (failures not unexpected) ...
pmStore: Missing metric value(s)

numpmid == 0 tests (failures expected) ...
pmResult ... numpmid: 0
pmStore: Insufficient elements in list
__pmControlLog: Insufficient elements in list

numval == 0 tests (failures expected) ...
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): No PMCD agent for domain of request
  30.0.14 (sampledso.long.write_me): No values returned!
  29.0.5 (sample.colour): No PMCD agent for domain of request
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): numval: 3 valfmt: 0 vlist[]:
    inst [0 or ???] value NUMBER
    inst [1 or ???] value NUMBER
    inst [2 or ???] value NUMBER

numval < 0 tests (failures expected) ...
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): No PMCD agent for domain of request
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): No PMCD agent for domain of request
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): numval: 3 valfmt: 0 vlist[]:
    inst [0 or ???] value NUMBER
    inst [1 or ???] value NUMBER
    inst [2 or ???] value NUMBER
Quitting need at least 4 metrics for profile tests
--- store.c case 3 ---
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): No PMCD agent for domain of request
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): No PMCD agent for domain of request

base store test (failures not unexpected) ...
pmStore: Missing metric value(s)

numpmid == 0 tests (failures expected) ...
pmResult ... numpmid: 0
pmStore: Insufficient elements in list
__pmControlLog: Insufficient elements in list

numval == 0 tests (failures expected) ...
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): No PMCD agent for domain of request
  30.0.14 (sampledso.long.write_me): No values returned!
  29.0.5 (sample.colour): No PMCD agent for domain of request
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): numval: 3 valfmt: 0 vlist[]:
    inst [0 or ???] value NUMBER
    inst [1 or ???] value NUMBER
    inst [2 or ???] value NUMBER

numval < 0 tests (failures expected) ...
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): No PMCD agent for domain of request
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): No PMCD agent for domain of request
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  2.0.0 (pmcd.control.debug): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  30.0.14 (sampledso.long.write_me): numval: 1 valfmt: 0 vlist[]:
   value NUMBER
  29.0.5 (sample.colour): numval: 3 valfmt: 0 vlist[]:
    inst [0 or ???] value NUMBER
    inst [1 or ???] value NUMBER
    inst [2 or ???] value NUMBER
Quitting need at least 4 metrics for profile tests
--- store.c case 4 ---
pmResult ... numpmid: 3
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER

base store test (failures not unexpected) ...
pmStore: No permission to perform requested operation

numpmid == 0 tests (failures expected) ...
pmResult ... numpmid: 0
pmStore: Insufficient elements in list
__pmControlLog: Insufficient elements in list

numval == 0 tests (failures expected) ...
pmResult ... numpmid: 3
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
  253.2.4 (simple.now): No values returned!
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER

numval < 0 tests (failures expected) ...
pmResult ... numpmid: 3
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
  253.2.4 (simple.now): numval: 1 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
  253.2.4 (simple.now): No PMCD agent for domain of request
pmStore: Missing metric value(s)
__pmControlLog: OK
pmResult ... numpmid: 3
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
  253.2.4 (simple.now): numval: 1 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
  253.2.4 (simple.now): numval: 3 valfmt: 0 vlist[]:
    inst [0 or "sec"] value NUMBER
    inst [1 or "min"] value NUMBER
    inst [2 or "hour"] value NUMBER
Quitting need at least 4 metrics for profile tests
