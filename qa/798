#! /bin/sh
# PCP QA Test No. 798
# Exercise dbpmda use with the Python nfsclient PMDA
#
# Copyright (c) 2013,2018 Red Hat.
#

seq=`basename $0`
echo "QA output created by $seq"

. ./common.python

[ -d $PCP_PMDAS_DIR/nfsclient ] || _notrun "nfsclient PMDA is not installed"

$python -c "from pcp import pmda" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python pcp pmda module not installed"

status=1
rm -f $seq.out
wordsize=`$python -c 'import ctypes; print(ctypes.sizeof(ctypes.c_long))'`
if [ $wordsize -eq 4 ]
then
    ln $seq.out.32 $seq.out
elif [ $wordsize -eq 8 ]
then
    ln $seq.out.64 $seq.out
else
    echo "Could not detect machine word size using python"
    exit
fi
python_path=`which $python`

_cleanup()
{
    cd $here
    [ -f $PCP_VAR_DIR/config/pmda/$domain.0.$seq ] && \
	_restore_config $PCP_VAR_DIR/config/pmda/$domain.0
    $sudo rm -f $PCP_PMDAS_DIR/nfsclient/nfsclient.log
    rm -f $tmp.*
}

trap "_cleanup; exit \$status" 0 1 2 3 15
rm -f $seq.full

_filter()
{
    tee -a $here/$seq.full \
    | $here/src/sortinst -v \
    | sed \
	-e "s;$PCP_PMDAS_DIR;\$PCP_PMDAS_DIR;" \
	-e "s;$script;pmdanfsclient.python;" \
	-e "s; $python_path; \$PYTHON;" \
	-e "s; $python; \$PYTHON;" \
	-e '/pmResult/s/ .* numpmid/ ... numpmid/' \
	-e '/[0-9][0-9]:[0-9][0-9]:[0-9][0-9]/s/[^ ]*/TIMESTAMP/' \
	-e 's/ 32-bit int / 32-BIT /' \
	-e 's/ 32-bit unsigned int / 32-BIT /' \
	-e '/62\.8\.16[123]/s/valfmt: [01]/valfmt: 0-or-1/' \
    # end
}

_filter_pmda_log()
{
    tee -a $here/$seq.full \
    | sed \
	-e 's/^\(Log for pmda[^ ]* on\) .*/\1 HOST .../' \
	-e 's/^\(Log finished\) .*/\1 .../' \
	-e '/^$/d' \
    #end
}

_filter_indom()
{
    # for indom 62.0 the order of the instances (and hence internal
    # instance number depends on the version of perl and the phase
    # of the moon ...
    # pmInDom: 62.0
    # [  0] inst: 0 name: "/mnt/nfsv4"
    # [  1] inst: 1 name: "/mnt/nfs41"
    # [  2] inst: 2 name: "/ifs"
    # [  3] inst: 3 name: "/ifsfoo"
    # dbpmda> 
    # and similarly for
    # pmResult dump from 0x2529560 timestamp: 0.000000 10:00:00.000 numpmid: 1
    #   62.0.2 (<noname>): numval: 4 valfmt: 1 vlist[]:
    #   inst [1 or ???] value "/mnt/nfsv4"
    #   inst [2 or ???] value "/mnt/nfs41"
    #   inst [3 or ???] value "/ifs"
    #   inst [4 or ???] value "/ifsfoo"
    # dbpmda>
    #
    rm -f $tmp.1 $tmp.2 $tmp.3
    sed -e 's/inst \[1[0-4]/inst [N/' -e 's/inst \[[0-9]/inst [N/' \
    | $PCP_AWK_PROG '
BEGIN						{ part = 1 }
part == 2 && $1 == "dbpmda>"			{ part = 3 }
						{ outname = "'$tmp'." part; print >outname }
part == 1 && $1 == "pmInDom:" && $2 == "62.0"	{ part = 2 }'

    [ -f $tmp.1 ] && cat $tmp.1
    [ -f $tmp.2 ] && LC_COLLATE=POSIX sort --key 6 $tmp.2 \
    | $PCP_AWK_PROG '
NR == 1	{ printf "[  X] inst: X name: %s\n",$6 }
NR > 1	{ printf "[X+%d] inst: X+%d name: %s\n", NR-1, NR-1, $6 }'
    [ -f $tmp.3 ] && cat $tmp.3
}

# real QA test starts here
domain=62
[ -f $PCP_VAR_DIR/config/pmda/$domain.0 ] && \
    _save_config $PCP_VAR_DIR/config/pmda/$domain.0
$sudo rm -f $PCP_VAR_DIR/config/pmda/$domain.0
script=pmdanfsclient.python
cd "$PCP_PMDAS_DIR/nfsclient"

# create a root namespace file for dbpmda to use
PCP_PYTHON_PMNS=root $python $script > $tmp.root

# create a set of commands for dbpmda
cat >$tmp.cmds <<End-of-File
open pipe $python_path $script
# on some platforms this may take a while ...
wait 2
getdesc on
desc nfsclient.export
desc nfsclient.mountpoint
desc nfsclient.options.string
desc nfsclient.options.proto
desc nfsclient.options.vers
fetch nfsclient.export
fetch nfsclient.mountpoint
fetch nfsclient.options.string
fetch nfsclient.options.proto
fetch nfsclient.options.vers
fetch nfsclient.options.vers
instance $domain.0
End-of-File

# create a set of commands for dbpmda
cat >$tmp.v3cmds <<End-of-File
open pipe $python_path $script
# on some platforms this may take a while ...
wait 2
getdesc on
desc nfsclient.export
desc nfsclient.options.mountaddr
fetch nfsclient.export
fetch nfsclient.options.mountaddr
fetch nfsclient.options.mountvers
fetch nfsclient.options.mountport
fetch nfsclient.options.mountproto
fetch nfsclient.ops.readdirplus.ops
fetch nfsclient.ops.readdirplus.ntrans
fetch nfsclient.ops.readdirplus.timeouts
fetch nfsclient.ops.readdirplus.bytes_sent
fetch nfsclient.ops.readdirplus.bytes_recv
fetch nfsclient.ops.readdirplus.queue
fetch nfsclient.ops.readdirplus.rtt
fetch nfsclient.ops.readdirplus.execute
instance $domain.0
End-of-File

# create a set of commands for dbpmda and nfsv4.2
cat >$tmp.42cmds <<EOF
open pipe $python_path $script
# on some platforms this may take a while ...
wait 2
getdesc on
desc nfsclient.nfsv4
desc nfsclient.ops.seek.ops
desc nfsclient.ops.seek.ntrans
desc nfsclient.ops.seek.timeouts
desc nfsclient.ops.seek.bytes_sent
desc nfsclient.ops.seek.bytes_recv
desc nfsclient.ops.seek.queue
desc nfsclient.ops.seek.rtt
desc nfsclient.ops.seek.execute
desc nfsclient.ops.allocate.ops
desc nfsclient.ops.allocate.ntrans
desc nfsclient.ops.allocate.timeouts
desc nfsclient.ops.allocate.bytes_sent
desc nfsclient.ops.allocate.bytes_recv
desc nfsclient.ops.allocate.queue
desc nfsclient.ops.allocate.rtt
desc nfsclient.ops.allocate.execute
desc nfsclient.ops.deallocate.ops
desc nfsclient.ops.deallocate.ntrans
desc nfsclient.ops.deallocate.timeouts
desc nfsclient.ops.deallocate.bytes_sent
desc nfsclient.ops.deallocate.bytes_recv
desc nfsclient.ops.deallocate.queue
desc nfsclient.ops.deallocate.rtt
desc nfsclient.ops.deallocate.execute
fetch nfsclient.nfsv4
fetch nfsclient.ops.seek.ops
fetch nfsclient.ops.seek.ntrans
fetch nfsclient.ops.seek.timeouts
fetch nfsclient.ops.seek.bytes_sent
fetch nfsclient.ops.seek.bytes_recv
fetch nfsclient.ops.seek.queue
fetch nfsclient.ops.seek.rtt
fetch nfsclient.ops.seek.execute
fetch nfsclient.ops.allocate.ops
fetch nfsclient.ops.allocate.ntrans
fetch nfsclient.ops.allocate.timeouts
fetch nfsclient.ops.allocate.bytes_sent
fetch nfsclient.ops.allocate.bytes_recv
fetch nfsclient.ops.allocate.queue
fetch nfsclient.ops.allocate.rtt
fetch nfsclient.ops.allocate.execute
fetch nfsclient.ops.deallocate.ops
fetch nfsclient.ops.deallocate.ntrans
fetch nfsclient.ops.deallocate.timeouts
fetch nfsclient.ops.deallocate.bytes_sent
fetch nfsclient.ops.deallocate.bytes_recv
fetch nfsclient.ops.deallocate.queue
fetch nfsclient.ops.deallocate.rtt
fetch nfsclient.ops.deallocate.execute
EOF
# iterate over our pre-canned mountstats files
test="$here/nfsclient"
for file in $test/*.qa
do
    export NFSCLIENT_MOUNTSTATS_PATH="$file"
    echo === Test case: `basename $file`
    $sudo rm -f nfsclient.log
    $sudo TERM=ansi \
	sh -c ". /etc/pcp.env; dbpmda -n $tmp.root -ie" < $tmp.cmds 2>&1 \
	| _filter | _filter_indom
    pmsleep 0.5
    _filter_pmda_log < nfsclient.log
done

# iterate over pre-canned nfsv3 mountstat files
for file in $test/*3.qa
do
    export NFSCLIENT_MOUNTSTATS_PATH="$file"
    echo === Test case: `basename $file`
    $sudo rm -f nfsclient.log
    $sudo TERM=ansi \
	sh -c ". /etc/pcp.env; dbpmda -n $tmp.root -ie" < $tmp.v3cmds 2>&1 \
	| _filter | _filter_indom
    pmsleep 0.5
    _filter_pmda_log < nfsclient.log
done

# iterate over pre-canned nfsv4.2 mountstat files
for file in $test/*42.qa
do
    export NFSCLIENT_MOUNTSTATS_PATH="$file"
    echo === Test case: `basename $file`
    $sudo rm -f nfsclient.log
    $sudo TERM=ansi \
	sh -c ". /etc/pcp.env; dbpmda -n $tmp.root -ie" < $tmp.42cmds 2>&1 \
	| _filter | _filter_indom
    pmsleep 0.5
    _filter_pmda_log < nfsclient.log
done

status=0
