#!/bin/sh
# PCP QA Test No. 1474
# exercise PM_CTXFLAG_METADATA_ONLY and pmlogrewrite
#
# Copyright (c) 2023 Ken McDonell.  All Rights Reserved.
#

if [ $# -eq 0 ]
then
    seq=`basename $0`
    echo "QA output created by $seq"
else
    # use $seq from caller, unless not set
    [ -n "$seq" ] || seq=`basename $0`
    echo "QA output created by `basename $0` $*"
fi

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check

which xz >/dev/null 2>&1 || _notrun "No xz binary installed"

time=`which time`
[ -z "$time" ] && _notrun "can't find /bin/time nor /usr/bin/time"


_cleanup()
{
    cd $here
    $sudo rm -rf $tmp $tmp.*
}

status=0	# success is the default!
trap "_cleanup; exit \$status" 0 1 2 3 15

_filter()
{
    sed \
	-e "s@$tmp@TMP@g" \
    # end
}
_summary()
{
    $PCP_AWK_PROG '
$1 == "cputime:" { printf "'"$1"': %.2fcpu (%.2fusr + %.2fsys)\n",$2+$3, $2, $3 }
$1 != "cputime:" { print }'
}

# deal with differences in time(1) ... stdout reports <user time> <sys time>
# as floating point numbers of seconds
# known variants  ...
# real	0m0.002s
# user	0m0.000s
# sys	0m0.002s
#
# real        0.0
# user        0.0
# sys         0.0
#
# 0.60user 0.01system ...
#
_time()
{
    echo "_time: command: $*" >>$seq_full
    $time $* >/dev/null 2>$tmp.clock
    cat $tmp.clock >>$seq_full
    sed -E  <$tmp.clock \
	-e '/^(real|user|sys)[ 	]/{
s/([0-9])m/\1 /
s/([0-9])s$/\1/
}' \
	-e '/[0-9]user [0-9]/{
s/user/ user/
s/system/ system/
}' \
    | $PCP_AWK_PROG '
BEGIN		{ u = "?"; s = "?" }
$1 == "user"	{ if (NF == 3) u = 60*$2 + $3
		  if (NF == 2) u = $2
		}
$1 == "sys"	{ if (NF == 3) s = 60*$2 + $3
		  if (NF == 2) s = $2
		}
$2 == "user" && $4 == "system"	{
		  u = $1
		  s = $3
		}
END		{ print u,s }' \
    | tee -a $seq_full
}

# archives/pcp-pidstat-process-args.0.xz is the largest QA archive(s)
# we have (to date) at 361Mb expanded ...
#
base=pcp-pidstat-process-args
mkdir $tmp
cd $tmp
pmlogcp $here/archives/$base .
_time xzcat $base.0.xz | sed -e 's/^/cputime: /' >$tmp.time
_summary <$tmp.time "data uncompress" | tee -a $seq_full >$tmp.tmp
data=`sed -n <$tmp.tmp -e '/[0-9]cpu (/{
s/cpu (.*//
s/.* //p
}'`
echo "data=$data" >>$seq_full
_time xzcat $base.meta.xz | sed -e 's/^/cputime: /' >$tmp.time
_summary <$tmp.time "metadata uncompress" | tee -a $seq_full >$tmp.tmp
metadata=`sed -n <$tmp.tmp -e '/[0-9]cpu (/{
s/cpu (.*//
s/.* //p
}'`
echo "metadata=$metadata" >>$seq_full

# real QA test starts here
_time pmlogrewrite -Dappl3 -qi $base | sed -e 's/^/cputime: /' >$tmp.time
_summary logrewrite <$tmp.time | tee -a $seq_full >$tmp.tmp
rewrite=`sed -n <$tmp.tmp -e '/[0-9]cpu (/{
s/cpu (.*//
s/.* //p
}'`
echo "rewrite=$rewrite" >>$seq_full

# expect the rewrite time to be closer to the metadata time than the
# data time
#
echo "$data $rewrite $metadata" | $PCP_AWK_PROG '
function abs(a,b)
{
    if (a >= b)
	return a-b
    else
	return b-a
}
{ d1 = abs($1 - $2)
  d2 = abs($2 - $3)
  if (d2 < d1)
    print "pmlogrewrite time closer to metadata decompress than data decompress"
  else
    print "Failed closer test: data-to-pmlogrewrite",d1,"pmlogrewrite-to-metadata",d2
}'

# expect the data time to be _at least_ 40 times the rewrite time,
# but need to set bar at 20 times thanks to slow VMs
#
echo "$data $rewrite" | $PCP_AWK_PROG '
{ if ($1 >= 20 * $2)
    print "pmlogrewrite time more than 20 times faster than data decompress time"
  else
    print "Failed 20 times test: pmlogrewrite",$2,"data decompress",$1
}'

# success, all done
exit
