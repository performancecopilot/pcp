#
# Copyright (c) 2000,2003 Silicon Graphics, Inc.  All Rights Reserved.
# Copyright (c) 2010 Aconex.  All Rights Reserved.
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
# 
# This file is sourced by PCP scripts to set the environment
# variables defined in the file named $PCP_CONF (or /etc/pcp.conf
# if $PCP_CONF is not defined). Any variable already defined in
# the environment is not changed. 
#
# Note: any variables NOT starting with PCP_ will be ignored.
# This is a security issue so don't change it.
#
if [ -z "$PCP_ENV_DONE" ]
then
    if [ -n "$PCP_CONF" ]
    then
	__CONF="$PCP_CONF"
    elif [ -n "$PCP_DIR" ]
    then
	__CONF="$PCP_DIR/etc/pcp.conf"
    else
	__CONF=/etc/pcp.conf
    fi
    if [ ! -f "$__CONF" ]
    then
	echo "pcp.env: Fatal Error: \"$__CONF\" not found" >&2
	exit 1
    fi
    eval `sed -e 's/"//g' $__CONF \
    | awk -F= '
/^PCP_/ && NF == 2 {
	    vars=vars" "$1
	    printf "%s=${%s:-\"%s\"}\n", $1, $1, $2
	}
END	{ print "export", vars }'`

    # prevent doing all of this more than once per process ...
    #
    PCP_ENV_DONE=y; export PCP_ENV_DONE
fi

# Always need to set $PATH ... sudo -E leaves $PCP_ENV_DONE set, but
# clears/resets $PATH.
#
# Note when we're adding directories into $PATH (as opposed to the
# directory already being in $PATH), the order is important: any
# dirs with PCP-specific binaries should end up ahead of more generic
# dirs in the final $PATH to avoid conflicts with names of non-pcp
# binaries, by ensuring the pcp ones are found first.
#
# Also, there are a small number of commands that we need, e.g. in
# PMDA Install scripts, that are not necessariy on the default $PATH,
# e.g. chown in /usr/sbin on *BSD.  Put these after the PCP ones, but
# ahead of the default $PATH.
#
for dir in /usr/sbin \
	${PCP_BIN_DIR} ${PCP_BINADM_DIR} \
	${PCP_SHARE_DIR}/bin ${PCP_PLATFORM_PATHS}
do
    if [ -d $dir ]
    then
	if echo ":$PATH:" | grep ":$dir:" >/dev/null 2>&1
	then
	    :
	else
	    PATH="$dir:$PATH"
	fi
    fi
done
export PATH

# Also need to always do this because it may be resetting things
# that sudo has cleared from the environment, e.g. PERL5LIB
#
# Optionally augment or over-ride settings with per-user configuration
#
if [ -f $HOME/.pcp/pcp.conf ]
then
    eval `sed -e 's/"//g' -e '/^#/d' $HOME/.pcp/pcp.conf \
    | awk -F= '
NF == 2 {
	vars=vars" "$1
	printf "%s=${%s:-\"%s\"}\n", $1, $1, $2
    }
END	{ print "export", vars }'`
fi

# Find PIDs by matching the name ($1)
# Executable alias name avoidance algorithm ...
# - if name contains a / use it literally and consider nothing else
# - if name matches an executable in $PCP_BIN_DIR, use that full pathname
# - if name matches an executable in $PCP_BINADM_DIR, use that full pathname
# - if find(1) can locate name on this week's $PATH, use that full pathname
# - if name matches an executable in $PCP_BIN_DIR and/or $PCP_BINADM_DIR
#   and/or find(1) matches name, use _all_ of the pathnames in the order
#   above (needed e.g. for pmlogger in $PCP_BIN_DIR and symlink in
#   $PCP_BINADM_DIR)
# - if -a is specified also match on /name (this was the original behaviour
#   before the pathname matching was added)
# - otherwise use name as is
#
# and after all that, some filtering to remove processes that are definitely
# running in a hosted container
# (as described in https://github.com/performancecopilot/pcp/issues/101)
#
_get_pids_by_name()
{
    __all=false
    __verbose=false
    while true
    do
	if [ "X$1" = X-a ]
	then
	    __all=true
	    shift
	elif [ X"$1" = X-v ]
	then
	    __verbose=true
	    shift
	else
	    break
	fi
    done
    if [ $# -ne 1 ]
    then
	echo "Usage: _get_pids_by_name [-a] [-v] process-name" >&2
	exit 1
    fi
    if [ "X$tmp" = X ]
    then
	echo "_get_pids_by_name requires a \$tmp setting" >&2
	exit 1
    elif [ -d "$tmp" -a -w "$tmp" ]
    then
	__tmp="$tmp/pcp.env"	# from mktemp
    else
	__tmp=$tmp.pcp.env	# from PCP QA
    fi

    __name="$1"
    rm -f $__tmp.*
    touch $__tmp.path
    case "$1"
    in
	*/*)
	    rm -f $__tmp.path
	    ;;
	*)
	    if [ -n "$PCP_BIN_DIR" -a -x "$PCP_BIN_DIR/$1" ]
	    then
		if ! grep "$PCP_BIN_DIR/$1" $__tmp.path >/dev/null
		then
		    echo "$PCP_BIN_DIR/$1" >>$__tmp.path
		fi
	    fi
	    if [ -n "$PCP_BINADM_DIR" -a -x "$PCP_BINADM_DIR/$1" ]
	    then
		if ! grep "$PCP_BINADM_DIR/$1" $__tmp.path >/dev/null
		then
		    echo "$PCP_BINADM_DIR/$1" >>$__tmp.path
		fi
	    fi
	    __which="`which "$1" 2>/dev/null`"
	    if [ -n "$__which" ]
	    then
		if ! grep "$__which" $__tmp.path >/dev/null
		then
		    echo "$__which" >>$__tmp.path
		fi
	    fi
	    ;;
    esac

    # Algorithm ... all ps(1) variants have a time of the form MM:SS
    # or HH:MM:SS or HH:MM.SS before the psargs field, so we're using
    # this as the search anchor.
    #
    # Matches with $1 (process-name) occur if the first psarg is one
    # of the paths identified above or ends in /$1 (if -a specified)
    # or starts ($1) (blame macOS for the last one)

    # some preprocessing to condition the ps(1) output lines
    #
    cat <<End-of-File >$__tmp.sed
s/$/ /
s/[ 	][ 	]*/ /g
s/^ //
s/^[^ ]* //
End-of-File
    if [ -f $__tmp.path ]
    then
	# not a literal use of $1, at least one matching pathname found
	#
	sed <$__tmp.path >>$__tmp.sed \
	    -e 's/\//\\\//g' \
	    -e 's/.*/\/[0-9][:\\.][0-9][0-9]  *& \/s\/ .*\/\/p/'
    fi
    # optionally add -a case
    #
    if $__all
    then
	echo "$1" | sed >>$__tmp.sed \
	    -e 's/\//\\\//g' \
	    -e 's/.*/\/[0-9][:\\.][0-9][0-9]  *[^ ]*\\\/& \/s\/ .*\/\/p/'
    fi
    # add literal cases
    #
    # exact match
    echo "$1" | sed >>$__tmp.sed \
	-e 's/\//\\\//g' \
	-e 's/.*/\/[0-9][:\\.][0-9][0-9]  *& \/s\/ .*\/\/p/'
    # macOS variant
    echo "$1" | sed >>$__tmp.sed \
	-e 's/\//\\\//g' \
	-e 's/.*/\/[0-9][:\\.][0-9][0-9]  *(&) \/s\/ .*\/\/p/'

    # need to sort in case of multiple matches from the sed(1) patterns
    #
    $PCP_PS_PROG $PCP_PS_ALL_FLAGS \
    | sed -n -f $__tmp.sed \
    | sort -n -u \
    | while read __pid
    do
	if $__verbose
	then
	    $PCP_PS_PROG $PCP_PS_ALL_FLAGS 2>&1 | $PCP_AWK_PROG '
$2 == "PID"		{ print }
$2 == '"$__pid"'	{ print }' >$__tmp.ps
	fi
	if [ -f /proc/$__pid/cgroup ]
	then
	    # check the last line of /proc/$__pid/cgroup ..
	    #
	    # known non-container patterns
	    # 0::/system.slice/
	    # 0::/user.slice/
	    # 0::/init.scope
	    # 1:name=systemd:/
	    # 1:cpuset:/
	    # 1:blkio:/
	    #
	    # known container patterns
	    # 0::/machine.slice/libpod-<uuid>.scope/container/system.slice/
	    #
	    __cgroups=`tail -1 /proc/$__pid/cgroup 2>/dev/null`
	    case "$__cgroups"
	    in
		# if cgroup file goes away or cannot be read, silently
		# assume the process was not in a container
		#
		''|0::/system.slice/*|0::/user.slice/*|0::/init.scope|1:name=systemd:/*|1:cpuset:/*|1:blkio:/*)
			if $__verbose
			then
			    echo >&2 "Info: _get_pids_by_name: not in container"
			    cat >&2 $__tmp.ps
			fi
			echo $__pid
			;;
	    	0::/machine.slice/*/container/*)
			# skip this one
			if $__verbose
			then
			    echo >&2 "Info: _get_pids_by_name: in container, skipped"
			    cat >&2 $__tmp.ps
			fi
			;;
		*)
			if $__verbose
			then
			    echo >&2 "Warning: _get_pids_by_name: unknown cgroups: \"$__cgroups\""
			    $PCP_PS_PROG $PCP_PS_ALL_FLAGS 2>&1 | $PCP_AWK_PROG '
$2 == "PID"	{ print }
$2 == '"$__pid"'	{ print }' >&2
			fi
			echo $__pid
			;;
	    esac
	else
	    if $__verbose
	    then
		echo >&2 "Info: _get_pids_by_name: no /proc/$__pid/cgroup file, assumed not in container"
		cat >&2 $__tmp.ps
	    fi
	    echo $__pid
	fi
    done
    
    rm -f $__tmp.*
}

# Redundant now ... use _get_pids_by_name -a ...
# Maintained here for backwards compatibility.
#
_get_pids_by_args()
{
    if [ $# -lt 1 ]
    then
	echo "Usage: _get_pids_by_args process-name [args...]" >&2
	exit 1
    fi
    # Matches on command and its arguments ... note escaping any / in
    # the process name happens in _get_pids_by_name()
    #
    _get_pids_by_name -a "$@"
}

# Usage: _ps_full_by_name [-v] name [arg_pattern]
#
# ps(1) full output, but only for processes with command name that
# matches "name" (c/o _get_pids_by_name(), so exact name, no REs here
# and ignore processes running in a container), optionally filtered to
# be only those with command line args matching (in the grep -E sense)
# "arg_pattern"
#
# -v for verbose output (on stderr)
#
_ps_full_by_name()
{
    if [ X"$1" = X-v ]
    then
	__verbose=true
	shift
    else
	__verbose=false
    fi
    __pidlist=`_get_pids_by_name "$1" | tr '\012' ' ' | sed -e 's/ $//'`
    $__verbose && echo >&2 "Info: PIDs=\"$__pidlist\""
    if [ -z "$__pidlist" ]
    then
	return
    fi
    # remove ps arg -e for linux, -a for *BSD, etc.
    # configure.ac currently knows about these settings
    #    pcp_ps_all_flags=-ef
    #    pcp_ps_all_flags=-efw
    #    pcp_ps_all_flags=-efww
    #    pcp_ps_all_flags=-efW
    #    pcp_ps_all_flags="-axw -o user,pid,ppid,cpu,stime,tty,time,command"
    #    pcp_ps_all_flags="-axww -o user,pid,ppid,%cpu,start,tty,time,args"
    #    pcp_ps_all_flags=auxww
    #
    __args=`echo X"$PCP_PS_ALL_FLAGS" | sed -e 's/^X//' -e 's/-ef/-f/' -e 's/-ax/-x/' -e 's/aux/ux/'`
    __args="$__args `echo "$__pidlist" | sed -e 's/ / -p /g' -e 's/^/-p /'`"
    $PCP_PS_PROG $__args 2>&1 \
    | if [ $# -eq 1 ]
      then
	  cat
      else
	  grep -E "PPID|$2"
      fi
}
