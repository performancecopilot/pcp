# nix/bcc.nix
#
# NixOS module for BCC PMDA (eBPF metrics).
#
# ══════════════════════════════════════════════════════════════════════════════
# DEPRECATED: pmdabcc is deprecated upstream and will be removed in a future
# PCP release. Use pmdabpf instead (see nix/bpf.nix).
#
# From pmdabcc(1):
#   "This PMDA is now deprecated and will be removed in a future release,
#    transition to using its replacement pmdabpf(1) instead."
#
# This module is provided for reference but is NOT functional on NixOS.
# No further development will be done on this module.
# ══════════════════════════════════════════════════════════════════════════════
#
# ─── Known Issues (will not be fixed) ─────────────────────────────────────────
#
# BCC compilation works but metrics don't register with pmcd:
# - pminfo bcc returns "Unknown metric name"
# - Modules compile but don't register metrics via pmcd pipe protocol
# - Log file path doesn't work correctly
#
# ─── Use pmdabpf Instead ──────────────────────────────────────────────────────
#
# pmdabpf is the supported replacement:
#   - Pre-compiled CO-RE eBPF (no runtime compilation)
#   - Works reliably on NixOS
#   - Provides runqlat, biolatency, oomkill, execsnoop, etc.
#   - Fast startup, ~512MB memory vs ~2GB for BCC
#   - Actively maintained
#
# ══════════════════════════════════════════════════════════════════════════════
#
# Architecture (for reference):
#   pmcd reads pmcd.conf which includes bcc PMDA entry
#   pmcd spawns pmdabcc as a pipe PMDA (binary protocol)
#   pmdabcc loads eBPF modules via BCC library
#   Grafana PCP Vector datasource queries pmproxy → pmcd → pmdabcc
#
{ config, lib, pkgs, ... }:
with lib;
let
  constants = import ./constants.nix;
  cfg = config.services.pcp;
  bccCfg = cfg.bcc;

  # Use the kernel from pkgs.linuxPackages (NixOS default).
  # Note: We can't use config.boot.kernelPackages.kernel here because it creates
  # an infinite recursion with fileSystems evaluation.
  #
  # This works for MicroVMs because they use the default NixOS kernel (pkgs.linuxPackages).
  # If you customize boot.kernelPackages, ensure it matches pkgs.linuxPackages or
  # the bind mounts will be at the wrong path.
  #
  # BCC uses uname -r to find headers at /lib/modules/$(uname -r)/build
  kernel = pkgs.linuxPackages.kernel;

  # All modules (defaults + extras)
  allModules = bccCfg.modules ++ bccCfg.extraModules;

  # Generate bcc.conf from enabled modules
  moduleConfigs = concatStringsSep "\n" (map (mod: ''
    [${mod.name}]
    module = ${if mod.module != null then mod.module else mod.name}
    cluster = ${toString mod.cluster}
    ${optionalString (mod.extraConfig != "") mod.extraConfig}
  '') allModules);

  bccConf = pkgs.writeText "bcc.conf" ''
    #
    # PCP BCC PMDA config - generated by NixOS
    # See pmdabcc(1) for configuration options
    #

    [pmda]
    modules = ${concatMapStringsSep "," (m: m.name) allModules}
    prefix = bcc.
    process_refresh = ${toString bccCfg.processRefresh}
    module_failure_fatal = ${if bccCfg.moduleFailureFatal then "True" else "False"}

    ${moduleConfigs}
  '';

  # Python path for BCC - use the same Python as PCP
  python = pkgs.python3;
  pythonVersion = python.pythonVersion;

in {
  # ═══════════════════════════════════════════════════════════════════════
  # Options interface
  # ═══════════════════════════════════════════════════════════════════════

  options.services.pcp.bcc = {
    enable = mkEnableOption "BCC PMDA for eBPF metrics (requires kernel eBPF support)";

    modules = mkOption {
      type = types.listOf (types.submodule {
        options = {
          name = mkOption {
            type = types.str;
            description = "Module name (used in config section header)";
          };
          module = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = "Module to load (defaults to name if not specified)";
          };
          cluster = mkOption {
            type = types.int;
            description = "Unique cluster ID (0-99 for BCC tools, 100-199 for PCP-specific)";
          };
          extraConfig = mkOption {
            type = types.str;
            default = "";
            description = "Additional config lines for this module";
          };
        };
      });
      default = [
        # Modules required for eBPF/BCC Overview dashboard
        { name = "runqlat"; cluster = 4; }
        { name = "biolatency"; cluster = 0; }
        { name = "tcptop"; cluster = 12; }
        { name = "tcplife"; cluster = 3; }
      ];
      description = ''
        BCC modules to enable. Default includes modules required for
        the Grafana eBPF/BCC Overview dashboard.
      '';
    };

    processRefresh = mkOption {
      type = types.int;
      default = 60;
      description = "Interval in seconds to refresh monitored processes (0 to disable)";
    };

    moduleFailureFatal = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Whether BCC PMDA should exit when a module fails to compile.
        Set to false for development (partial functionality) or true for production.
      '';
    };

    extraModules = mkOption {
      type = types.listOf (types.submodule {
        options = {
          name = mkOption { type = types.str; };
          module = mkOption { type = types.nullOr types.str; default = null; };
          cluster = mkOption { type = types.int; };
          extraConfig = mkOption { type = types.str; default = ""; };
        };
      });
      default = [];
      description = "Additional BCC modules beyond the dashboard defaults";
      example = literalExpression ''
        [
          { name = "netproc"; cluster = 40; }
          { name = "bioperpid"; cluster = 1; }
        ]
      '';
    };
  };

  # ═══════════════════════════════════════════════════════════════════════
  # Implementation
  # ═══════════════════════════════════════════════════════════════════════

  config = mkIf (cfg.enable && bccCfg.enable) {
    # Warning about deprecation
    warnings = [
      "pmdabcc is DEPRECATED and will be removed in a future PCP release. Use pmdabpf instead (services.pcp.bpf.enable = true)."
      "BCC PMDA is NOT functional on NixOS - metrics will not register with pmcd."
    ];

    # Add BCC to system packages for debugging
    environment.systemPackages = [ pkgs.bcc ];

    # Register BCC PMDA with pmcd via the pmdas option
    services.pcp.pmdas.bcc = {
      domain = 149;  # BCC domain ID
      type = "pipe";
      flags = "binary notready";
      command = let
        # Create wrapper script that sets up BCC environment
        # Note: BCC requires clang for runtime eBPF compilation
        # We use clang-unwrapped to avoid NixOS clang-wrapper validation issues
        # that cause objdump to fail during pmdabcc initialization

        # Create an ld wrapper that prepends glibc library path
        # Problem: cffi runs `ld -t -L <pcp_lib> -o /dev/null -lc` to verify libraries
        # This fails because glibc isn't in <pcp_lib>. Our wrapper injects -L<glibc>/lib
        ldWrapper = pkgs.writeShellScript "ld" ''
          exec ${pkgs.llvmPackages.bintools-unwrapped}/bin/ld -L${pkgs.glibc}/lib "$@"
        '';

        # Create a clang wrapper that adds kernel include paths for BPF compilation
        # BCC calls clang directly without respecting environment variables for includes
        # This wrapper prepends the NixOS kernel dev paths
        kernelDev = "${kernel.dev}/lib/modules/${kernel.version}";
        clangWrapper = pkgs.writeShellScript "clang" ''
          exec ${pkgs.llvmPackages.clang-unwrapped}/bin/clang \
            -I${kernelDev}/build/include/generated \
            -I${kernelDev}/build/include \
            -I${kernelDev}/source/include \
            -I${kernelDev}/source/arch/x86/include \
            -I${kernelDev}/build/arch/x86/include/generated \
            -I${kernelDev}/source/include/uapi \
            -I${kernelDev}/source/arch/x86/include/uapi \
            "$@"
        '';

        # Directory containing our wrappers (must be first in PATH)
        wrapperDir = pkgs.runCommand "bcc-wrapper-dir" {} ''
          mkdir -p $out/bin
          ln -s ${ldWrapper} $out/bin/ld
          ln -s ${clangWrapper} $out/bin/clang
        '';

        bccWrapper = pkgs.writeShellScript "pmdabcc-wrapper" ''
          # BCC Python bindings
          export PYTHONPATH="${pkgs.bcc}/lib/python${pythonVersion}/site-packages:${cfg.package}/lib/python${pythonVersion}/site-packages"

          # Put our wrappers FIRST in PATH:
          # - clang wrapper: adds kernel include paths for BPF compilation
          # - ld wrapper: adds -L<glibc>/lib for cffi library checks
          # Also add kmod for modprobe (needed by BCC for loading kernel modules)
          # See: nix/tests/BCC_PMDA_DEFECT.md for details
          export PATH="${wrapperDir}/bin:${pkgs.llvmPackages.llvm}/bin:${pkgs.llvmPackages.bintools-unwrapped}/bin:${pkgs.bcc}/bin:${pkgs.kmod}/bin:$PATH"

          # Library paths for dynamic linking (required for pcp.pmapi to find libpcp.so)
          export LD_LIBRARY_PATH="${cfg.package}/lib:${pkgs.glibc}/lib''${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"

          # Provide library paths that would normally come from the wrapper
          export NIX_CFLAGS_COMPILE="-isystem ${pkgs.glibc.dev}/include -isystem ${kernel.dev}/include"
          export NIX_LDFLAGS="-L${pkgs.glibc}/lib"

          # Library search paths (for tools that respect these variables)
          export LIBRARY_PATH="${pkgs.glibc}/lib:${cfg.package}/lib"
          export LDFLAGS="-L${pkgs.glibc}/lib"

          # Kernel headers for eBPF compilation
          # DO NOT set BCC_KERNEL_SOURCE - this breaks split-layout detection!
          # Instead, we create symlinks at the NixOS kernel modules path to our bind mounts
          # See systemd.tmpfiles.rules for the symlink creation

          # Disable wrapper purity enforcement
          export NIX_ENFORCE_PURITY=0

          # Override PCP_PMDAS_DIR so pmdabcc.python finds our custom config
          # pmdabcc.python uses: pmGetConfig('PCP_PMDAS_DIR') + '/bcc/bcc.conf'
          # Our config is at: /var/lib/pcp/config/bcc/bcc.conf
          # So we set PCP_PMDAS_DIR=/var/lib/pcp/config
          export PCP_PMDAS_DIR=/var/lib/pcp/config

          # Log file for debugging (pmdabcc.python uses the -l flag)
          exec ${cfg.package}/bin/pmpython \
            ${cfg.package}/var/lib/pcp/pmdas/bcc/pmdabcc.python \
            -l /var/log/pcp/pmcd/bcc.log \
            "$@"
        '';
      in "${bccWrapper} -d 149";
    };

    # Create BCC config directory and files
    # Note: /var/lib/pcp/config is owned by pcp:pcp, so subdirs must also be pcp-owned
    # to avoid "unsafe path transition" errors from systemd-tmpfiles
    systemd.tmpfiles.rules = [
      # Writable config directory for BCC (must be pcp:pcp to match parent)
      "d  /var/lib/pcp/config/bcc  0755 pcp pcp -"
      "d  /var/log/pcp/pmcd        0755 root root -"

      # Create kernel headers mount points for BCC at /lib/modules/VERSION
      "d  /lib/modules  0755 root root -"
      "d  /lib/modules/${kernel.version}  0755 root root -"
      "d  /lib/modules/${kernel.version}/build  0755 root root -"
      "d  /lib/modules/${kernel.version}/source  0755 root root -"

      # Copy BCC config (using L+ to create symlink, since C doesn't work well here)
      # The config is read-only which is fine for the PMDA
      "L+ /var/lib/pcp/config/bcc/bcc.conf - - - - ${bccConf}"

      # Symlink BCC module Python files from package
      "L+ /var/lib/pcp/config/bcc/modules - - - - ${cfg.package}/var/lib/pcp/pmdas/bcc/modules"
    ];

    # Bind mount kernel dev headers to /lib/modules/VERSION/{build,source}
    # NixOS BCC uses KERNEL_MODULES_DIR=/run/booted-system/... but that's a symlink we can't mount into
    # So we mount at /lib/modules/ and set BCC_KERNEL_SOURCE to point there
    fileSystems."/lib/modules/${kernel.version}/build" = {
      device = "${kernel.dev}/lib/modules/${kernel.version}/build";
      fsType = "none";
      options = [ "bind" "ro" ];
    };
    fileSystems."/lib/modules/${kernel.version}/source" = {
      device = "${kernel.dev}/lib/modules/${kernel.version}/source";
      fsType = "none";
      options = [ "bind" "ro" ];
    };
  };
}
