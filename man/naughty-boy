#!/bin/sh
#
# "He's not the Messiah. He's a very naughty boy!” ...
# Brian's mother in Monty Python's Life Of Brian.
#
# "make check" fails in the man dir on some platforms (Fedora 39
# and 40 specifically) because the maintainers of the checking tool
# we're forced to use are clueless about troff and its history
# + whitespace at the end of a troff input line always was, and
#   always will be, OK.
# + .SH followed by .PP is always benign
#
# To be complete this really needs the make to descend into the
# man_src directory to make all symlinks that point to the hidden
# man pages squirreled away in the src directories
#

usage="Usage: naughty-boy [-do] [file ...]"

tmp=/var/tmp/naughty-boy-$$
status=0
trap "rm -f $tmp.*; exit \$status" 0 1 2 3 15

debug=false
oneshot=false
while getopts "do?" c
do
    case $c
    in
	d)	# debug
		debug=true
		;;
	o)	# quit at first failure
		oneshot=true
		;;
	?)	echo >&2 "$usage"
		exit
		;;
    esac
done
shift `expr $OPTIND - 1`

if [ $# -gt 0 ]
then
    for arg; do echo $arg; done
else
    find man* -type f -o -type l
fi \
| while read f
do
    if grep -q '^\.SH ' <$f 2>/dev/null
    then
	# smells like troff man source ... not html, or an image, or ...
	# + \<space> at the end of the line is an escaped <space>
	#   and that's not a problem
	# + comments are NOT immune from this nonsense (I backed
	#   out the previous tricky sed to strip troff comment
	#   lines)
	#
	cat -n <$f >$tmp.n
	rm -f $tmp.err
	sed -e '/\\ $/d' <$tmp.n \
	| sed -n -e '/ $/s/$/[space at end of line]/p' >>$tmp.err
	# + .PP  after .SH
	#
	awk <$f >>$tmp.err '
$1 == ".SH"			{ seenSH = 1; next }
seenSH == 1 && $1 == ".PP"	{ printf "%6d\t[.PP after .SH]\n",NR }
				{ seenSH = 0 }'
	# \\f(xx for some invalid font ... only want BI (Times Bold-Italic),
	# CR, CB, CI (Courier Roman, Bold or Italic)
	#
	if head -1 <$f | grep 'generated by Pod::Man' >/dev/null
	then
	    # Pod::Man generates \f(CW ... sigh
	    #
	    :
	else
	    grep '\\f(..' <$tmp.n 2>/dev/null \
	    | sed -n >>$tmp.err \
		-e 's/\\f(BI/\\f(??/g' \
		-e 's/\\f(CR/\\f(??/g' \
		-e 's/\\f(CB/\\f(??/g' \
		-e 's/\\f(CI/\\f(??/g' \
		-e '/\\f([^?][^?]/s/$/ [dodgey font]/p'
	fi

	if [ -s $tmp.err ]
	then
	    echo "$f:"
	    cat $tmp.err
	    status=1
	    $oneshot && exit 1
	fi
    else
	$debug && echo "$f: skipped (not troff)"
    fi
done

exit
