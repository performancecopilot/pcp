name: macOS QA

on:
  workflow_dispatch:
  push:
    branches:
      - macos-qa-uplift

jobs:
  qa:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.ref_name }}

      - name: Update Homebrew
        run: brew update

      - name: Set up Python 3.13
        uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install macOS dependencies
        run: bash build/mac/scripts/install-deps.sh  # Install all deps (no --minimal)

      - name: Enable TCP stats
        run: |
          echo "Enabling TCP statistics for testing..."
          sudo sysctl -w net.inet.tcp.disable_access_to_stats=0
          sysctl net.inet.tcp.disable_access_to_stats

      - name: Configure PCP
        run: |
          # Use realpath to resolve macOS symlinks (/etc -> /private/etc, /var -> /private/var)
          # This matches the configuration used in Makepkgs for darwin
          ETC=$(realpath /etc)
          VAR=$(realpath /var)
          # Discover Homebrew Python prefix to install bindings to the right location
          PYTHON_PREFIX=$(python3 -c 'import sys; print(sys.prefix)')
          echo "Python prefix: $PYTHON_PREFIX"
          ./configure --sysconfdir=$ETC --localstatedir=$VAR --prefix=/usr/local --with-python-prefix=$PYTHON_PREFIX --with-qt=no

      - name: Build PCP
        run: |
          make -j$(sysctl -n hw.ncpu)

      - name: Create PCP users and groups
        run: |
          echo "Creating pcp user and group for daemons..."
          if ! dscl . -read /Groups/pcp &>/dev/null; then
            NEXT_GID=$(dscl . -list /Groups PrimaryGroupID | awk '{print $2}' | sort -n | tail -1)
            NEXT_GID=$((NEXT_GID + 1))
            sudo dscl . -create /Groups/pcp
            sudo dscl . -create /Groups/pcp PrimaryGroupID "$NEXT_GID"
            sudo dscl . -create /Groups/pcp RealName "PCP Group"
          fi
          if ! dscl . -read /Users/pcp &>/dev/null; then
            NEXT_UID=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
            NEXT_UID=$((NEXT_UID + 1))
            PCP_GID=$(dscl . -read /Groups/pcp PrimaryGroupID | awk '{print $2}')
            sudo dscl . -create /Users/pcp
            sudo dscl . -create /Users/pcp UserShell /usr/bin/false
            sudo dscl . -create /Users/pcp RealName "PCP System User"
            sudo dscl . -create /Users/pcp UniqueID "$NEXT_UID"
            sudo dscl . -create /Users/pcp PrimaryGroupID "$PCP_GID"
            sudo dscl . -create /Users/pcp NFSHomeDirectory /var/empty
          fi

          echo "Creating pcpqa user for testing..."
          if ! dscl . -read /Users/pcpqa &>/dev/null; then
            NEXT_UID=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
            NEXT_UID=$((NEXT_UID + 1))
            sudo dscl . -create /Users/pcpqa
            sudo dscl . -create /Users/pcpqa UserShell /bin/bash
            sudo dscl . -create /Users/pcpqa RealName "PCP QA User"
            sudo dscl . -create /Users/pcpqa UniqueID "$NEXT_UID"
            sudo dscl . -create /Users/pcpqa PrimaryGroupID 20
            sudo dscl . -create /Users/pcpqa NFSHomeDirectory /Users/pcpqa
            sudo mkdir -p /Users/pcpqa
            sudo chown pcpqa:staff /Users/pcpqa
          fi

      - name: Configure sudo for pcpqa
        run: |
          echo "Setting up passwordless sudo for pcpqa..."
          echo "pcpqa ALL=(ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/pcpqa
          sudo chmod 0440 /etc/sudoers.d/pcpqa

      - name: Install PCP
        run: sudo make install

      - name: Verify Python/Perl bindings installation
        run: |
          echo "=== Phase 2 Verification: Python/Perl Bindings ==="
          echo "Python search paths:"
          python3 -c "import sys; print('\n'.join(sys.path))"
          echo ""
          echo "Perl @INC paths:"
          perl -e 'print join("\n", @INC), "\n"'
          echo ""
          echo "Testing Python pcp.pmapi import..."
          python3 -c "from pcp import pmapi; print('✓ Python pcp.pmapi OK')" || {
            echo "✗ Python pcp.pmapi FAILED - checking installation location"
            find /usr/local/lib -name "pmapi.py" 2>/dev/null || echo "pmapi.py not found in /usr/local/lib"
            PYTHON_PREFIX=$(python3 -c 'import sys; print(sys.prefix)')
            find "$PYTHON_PREFIX/lib" -name "pmapi.py" 2>/dev/null || echo "pmapi.py not found in $PYTHON_PREFIX/lib either"
            # Set PYTHONPATH as fallback
            PY_VER=$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")')
            export PYTHONPATH="/usr/local/lib/python${PY_VER}/site-packages:${PYTHONPATH:-}"
            echo "Setting PYTHONPATH=$PYTHONPATH as fallback"
            echo "PYTHONPATH=$PYTHONPATH" >> $GITHUB_ENV
          }
          echo ""
          echo "Testing Perl PCP::PMDA module..."
          perl -e "use PCP::PMDA; print '✓ Perl PCP::PMDA OK\n'" || {
            echo "✗ Perl PCP::PMDA FAILED - setting PERL5LIB"
            export PERL5LIB="/usr/local/lib/perl5/site_perl:/usr/local/lib/perl5/vendor_perl:${PERL5LIB:-}"
            echo "PERL5LIB=$PERL5LIB" >> $GITHUB_ENV
          }

      - name: Rebuild PMNS
        run: |
          echo "Building PMNS root file from installed PMDA namespaces..."

          # Source pcp.conf from the real location (macOS resolves /etc -> /private/etc)
          if [ -f /etc/pcp.conf ]; then
            . /etc/pcp.conf
          elif [ -f /private/etc/pcp.conf ]; then
            . /private/etc/pcp.conf
          else
            echo "::error::pcp.conf not found in /etc or /private/etc"
            exit 1
          fi

          echo "Available PCP environment variables:"
          env | grep ^PCP_ | sort

          if [ -z "$PCP_VAR_DIR" ]; then
            echo "::error::PCP_VAR_DIR not set - pcp.conf not sourced correctly"
            exit 1
          fi

          echo ""
          echo "Checking where PMNS admin files were actually installed..."
          echo "Checking /usr/local/libexec/pcp/pmns/:"
          ls -la /usr/local/libexec/pcp/pmns/ 2>/dev/null || echo "Directory does not exist!"

          echo ""
          echo "Checking /usr/local/share/pcp/lib/pmns/:"
          ls -la /usr/local/share/pcp/lib/pmns/ 2>/dev/null || echo "Directory does not exist!"

          echo ""
          echo "PMNS directory contents (symlinks):"
          sudo ls -la $PCP_VAR_DIR/pmns/ || true

          echo ""
          echo "Testing if Rebuild symlink is accessible..."
          cd $PCP_VAR_DIR/pmns
          if [ -f Rebuild ]; then
            echo "✓ Rebuild symlink is accessible as a file"
            ls -l Rebuild

            # Try to resolve to absolute path
            if command -v realpath >/dev/null 2>&1; then
              REBUILD_REAL=$(realpath Rebuild)
              echo "Resolved to: $REBUILD_REAL"
              if [ -f "$REBUILD_REAL" ]; then
                echo "✓ Real file exists at $REBUILD_REAL"
                REBUILD_PATH="$REBUILD_REAL"
              else
                echo "::error::Real file does not exist at $REBUILD_REAL"
                exit 1
              fi
            else
              # Fallback: just use the symlink directly
              echo "realpath not available, using symlink directly"
              REBUILD_PATH="./Rebuild"
            fi
          else
            echo "::error::Rebuild is not accessible"
            exit 1
          fi

          echo ""
          echo "Running Rebuild script: $REBUILD_PATH"
          sudo "$REBUILD_PATH" -v

          echo ""
          echo "PMNS directory contents after rebuild:"
          sudo ls -la $PCP_VAR_DIR/pmns/

          if [ -f "$PCP_VAR_DIR/pmns/root" ]; then
            echo "✓ PMNS root file created successfully"
            echo "First 20 lines of root file:"
            sudo head -20 $PCP_VAR_DIR/pmns/root
          else
            echo "::error::PMNS root file was not created!"
            exit 1
          fi

      - name: Verify localhost DNS
        run: |
          echo "=== Checking localhost resolution ==="
          echo "Contents of /etc/hosts:"
          cat /etc/hosts

          echo ""
          echo "Checking for localhost entries..."
          if ! grep -q "127.0.0.1.*localhost" /etc/hosts; then
            echo "WARNING: No IPv4 localhost entry found - adding it"
            echo "127.0.0.1 localhost" | sudo tee -a /etc/hosts
          fi
          if ! grep -q "::1.*localhost" /etc/hosts; then
            echo "WARNING: No IPv6 localhost entry found - adding it"
            echo "::1 localhost" | sudo tee -a /etc/hosts
          fi

          echo ""
          echo "Testing DNS resolution speed..."
          time dscacheutil -q host -a name localhost

      - name: Start pmcd
        run: |
          sudo launchctl bootstrap system /Library/LaunchDaemons/io.pcp.pmcd.plist
          sudo launchctl kickstart -p -k system/io.pcp.pmcd

          echo "Waiting for pmcd to become available..."
          TIMEOUT=180
          ELAPSED=0
          INTERVAL=3

          while [ $ELAPSED -lt $TIMEOUT ]; do
            echo "Checking if pmcd is responding (${ELAPSED}s elapsed)..."

            if pcp 2>/dev/null; then
              echo "✓ pmcd service is responding!"
              break
            fi

            if pminfo -h localhost -f hinv.ncpu 2>/dev/null; then
              echo "✓ pmcd is accepting connections!"
              break
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "::error::pmcd failed to start within $TIMEOUT seconds"
            echo ""
            echo "=== pmcd process status ==="
            pgrep pmcd && echo "pmcd is running (PID: $(pgrep pmcd))" || echo "pmcd NOT running"
            ps aux | grep pmcd | grep -v grep || echo "No pmcd process found"

            echo ""
            echo "=== pmcd.log ==="
            sudo cat /var/log/pcp/pmcd/pmcd.log 2>/dev/null || echo "No pmcd.log found"

            echo ""
            echo "=== launchctl status ==="
            sudo launchctl list io.pcp.pmcd || echo "Service not in launchctl list"

            echo ""
            echo "=== pmcd network connections ==="
            sudo lsof -i -P | grep pmcd || echo "No network connections"

            exit 1
          fi

          echo ""
          echo "pmcd started successfully"
          pcp

      - name: Start pmlogger
        run: |
          sudo launchctl bootstrap system /Library/LaunchDaemons/io.pcp.pmlogger.plist
          sudo launchctl kickstart -p -k system/io.pcp.pmlogger
          sleep 3
          echo "pmlogger instances:"
          pgrep -l pmlogger || echo "No pmlogger processes yet (may take a moment)"

      - name: Start pmie
        run: |
          sudo launchctl bootstrap system /Library/LaunchDaemons/io.pcp.pmie.plist
          sudo launchctl kickstart -p -k system/io.pcp.pmie
          sleep 3
          echo "pmie instances:"
          pgrep -l pmie || echo "No pmie processes yet (may take a moment)"

      - name: Set QA directory permissions
        run: |
          echo "Giving pcpqa ownership of QA directory..."
          sudo chown -R pcpqa:staff qa/

      - name: Verify library paths for QA
        run: |
          echo "=== Verifying DYLD_LIBRARY_PATH fix ==="

          echo ""
          echo "1. Checking PCP library installation..."
          ls -la /usr/local/lib/libpcp* || echo "ERROR: No libpcp in /usr/local/lib"

          echo ""
          echo "2. Sourcing qa/common.rc and checking environment..."
          cd qa
          . ./common.rc
          echo "PCP_PLATFORM=$PCP_PLATFORM"
          echo "PCP_LIB_DIR=$PCP_LIB_DIR"
          echo "DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH"

          if [ "$PCP_PLATFORM" = "darwin" ]; then
            if [ -z "$DYLD_LIBRARY_PATH" ]; then
              echo "::error::DYLD_LIBRARY_PATH is not set on Darwin!"
              exit 1
            fi
            if ! echo "$DYLD_LIBRARY_PATH" | grep -q "$PCP_LIB_DIR"; then
              echo "::error::DYLD_LIBRARY_PATH does not contain PCP_LIB_DIR!"
              exit 1
            fi
            echo "✓ DYLD_LIBRARY_PATH correctly set"
          fi

          echo ""
          echo "3. Checking test binary linking..."
          if [ -f src/exercise ]; then
            otool -L src/exercise | head -20
          elif [ -f src/pducheck ]; then
            otool -L src/pducheck | head -20
          else
            echo "No test binaries found in qa/src/"
            ls src/*.o 2>/dev/null | head -5 || echo "No object files either"
          fi

          echo ""
          echo "4. Testing binary execution..."
          cd src
          for bin in exercise pducheck chkacc1; do
            if [ -f "$bin" ]; then
              echo "Testing $bin..."
              if ./$bin -? 2>&1 | head -3; then
                echo "✓ $bin executed successfully"
              else
                echo "✗ $bin failed (exit code $?)"
              fi
              break
            fi
          done

      - name: Rebuild test binaries with rpath
        run: |
          echo "=== Rebuilding test binaries in installed testsuite with rpath ==="

          # Ensure pcpqa owns the installed testsuite directory
          echo "Setting ownership of /var/lib/pcp/testsuite..."
          sudo chown -R pcpqa:staff /var/lib/pcp/testsuite

          cd /var/lib/pcp/testsuite/src

          echo "Before rebuild:"
          if [ -f exercise ]; then
            otool -L exercise | grep -E "(libpcp|rpath)" || echo "No rpath/libpcp found"
          fi

          # Clean and rebuild using GNUmakefile.install which adds rpath on Darwin
          sudo -u pcpqa make clean
          sudo -u pcpqa make

          echo ""
          echo "After rebuild:"
          if [ -f exercise ]; then
            otool -L exercise | grep -E "(libpcp|rpath)"
            echo ""
            echo "Testing rebuilt binary:"
            ./exercise -? 2>&1 | head -3 && echo "✓ Rebuilt binary works!"
          fi

      - name: Verify rpath in test binaries
        run: |
          echo "=== Phase 1 Verification: Test Binary rpath ==="
          echo "Checking torture_cache binary..."
          otool -L /var/lib/pcp/testsuite/src/torture_cache | grep libpcp || echo "ERROR: No libpcp reference found"
          echo ""
          echo "Checking LC_RPATH load command..."
          otool -l /var/lib/pcp/testsuite/src/torture_cache | grep -A2 LC_RPATH || echo "ERROR: No LC_RPATH found"
          echo ""
          echo "Expected: Should show /usr/local/lib/libpcp.4.dylib and LC_RPATH with path /usr/local/lib"

      - name: Fix PCP runtime directory permissions
        run: |
          echo "=== Fixing PCP runtime directory permissions for pcpqa ==="
          . /etc/pcp.conf
          sudo chown -R pcpqa:staff $PCP_RUN_DIR
          sudo chmod -R 755 $PCP_RUN_DIR
          echo "✓ Permissions fixed"
          ls -ld $PCP_RUN_DIR
          # Ensure user home directory exists for .pcp/run
          sudo mkdir -p /Users/runner/.pcp/run
          sudo chown -R runner:staff /Users/runner/.pcp
          echo "✓ User .pcp directory configured"

      - name: Verify environment configuration
        run: |
          echo "=== Phase 3 Verification: Environment ==="
          echo "TERM=${TERM:-<not set>}"
          echo "PYTHONPATH=${PYTHONPATH:-<not set>}"
          echo "PERL5LIB=${PERL5LIB:-<not set>}"
          echo ""
          echo "PCP runtime directory permissions:"
          . /etc/pcp.conf
          ls -ld $PCP_RUN_DIR
          ls -l $PCP_RUN_DIR | head -10 || echo "Directory empty"
          echo ""
          echo "pcpqa user home directory:"
          ls -ld /Users/runner/.pcp 2>/dev/null || echo "/Users/runner/.pcp does not exist"

      - name: Debug testsuite state before QA
        run: |
          echo "=========================================="
          echo "=== TESTSUITE STATE BEFORE QA TESTS ==="
          echo "=========================================="

          echo ""
          echo "=== 1. PCP Configuration ==="
          . /etc/pcp.conf
          echo "PCP_INC_DIR=$PCP_INC_DIR"
          echo "PCP_LIB_DIR=$PCP_LIB_DIR"
          echo "PCP_VAR_DIR=$PCP_VAR_DIR"
          echo "PCP_PLATFORM=$PCP_PLATFORM"

          echo ""
          echo "=== 1b. Path Resolution Check (realpath) ==="
          echo "/usr/local -> $(realpath /usr/local 2>/dev/null || echo 'FAILED')"
          echo "/usr/local/include -> $(realpath /usr/local/include 2>/dev/null || echo 'FAILED')"
          echo "PCP_INC_DIR resolved -> $(realpath "$PCP_INC_DIR" 2>/dev/null || echo 'FAILED')"
          echo "Homebrew prefix: $(brew --prefix 2>/dev/null || echo 'not installed')"
          echo ""
          echo "Raw string comparison test:"
          echo "  PCP_INC_DIR='$PCP_INC_DIR'"
          echo "  Equals '/usr/include/pcp'? $([ "$PCP_INC_DIR" = "/usr/include/pcp" ] && echo YES || echo NO)"
          echo "  Equals '/usr/local/include/pcp'? $([ "$PCP_INC_DIR" = "/usr/local/include/pcp" ] && echo YES || echo NO)"

          echo ""
          echo "=== 2. Check for libpcp.h in ALL locations ==="
          echo "Installed include dir:"
          ls -la "$PCP_INC_DIR/libpcp.h" 2>&1 || echo "  NOT FOUND"
          echo "Parent include dir:"
          ls -la "$PCP_INC_DIR/../libpcp.h" 2>&1 || echo "  NOT FOUND"
          echo "Testsuite src dir:"
          ls -la /var/lib/pcp/testsuite/src/libpcp.h 2>&1 || echo "  NOT FOUND"

          echo ""
          echo "=== 3. Check pmdadynamic binary state ==="
          DYNAMIC_DIR="/var/lib/pcp/testsuite/pmdas/dynamic"
          echo "Directory contents:"
          ls -la "$DYNAMIC_DIR/" | head -20
          echo ""
          echo "Binary exists and executable?"
          if [ -x "$DYNAMIC_DIR/pmdadynamic" ]; then
            echo "  YES - pmdadynamic is executable"
            echo "  Timestamp: $(stat -f '%Sm' "$DYNAMIC_DIR/pmdadynamic")"
            echo "  Size: $(stat -f '%z' "$DYNAMIC_DIR/pmdadynamic") bytes"
          else
            echo "  NO - pmdadynamic missing or not executable"
          fi
          echo ""
          echo "Source file timestamp:"
          stat -f '%Sm' "$DYNAMIC_DIR/dynamic.c" 2>&1 || echo "  dynamic.c not found"

          echo ""
          echo "=== 4. Check GNUmakefile in pmdas/dynamic ==="
          echo "CFLAGS section (lines 20-35):"
          sed -n '20,35p' "$DYNAMIC_DIR/GNUmakefile"

          echo ""
          echo "=== 5. Check localconfig existence ==="
          TESTSUITE="/var/lib/pcp/testsuite"
          if [ -f "$TESTSUITE/localconfig" ]; then
            echo "localconfig EXISTS - contents:"
            cat "$TESTSUITE/localconfig"
          else
            echo "localconfig DOES NOT EXIST - make setup will run"
          fi

          echo ""
          echo "=== 6. Test include path resolution ==="
          cd "$DYNAMIC_DIR"
          echo "From $PWD:"
          echo "  ../../src resolves to: $(cd ../../src 2>/dev/null && pwd || echo 'DOES NOT EXIST')"
          echo "  Contents of ../../src (if exists):"
          ls ../../src/*.h 2>/dev/null | head -5 || echo "    No .h files or dir doesn't exist"

          echo ""
          echo "=== 7. Dry-run make to see what would happen ==="
          cd "$TESTSUITE"
          echo "Running: make -n setup (dry run)"
          sudo -u pcpqa make -n setup 2>&1 | head -50 || echo "make -n failed"

          echo ""
          echo "=== 8. Check MAKEFLAGS environment ==="
          echo "MAKEFLAGS=${MAKEFLAGS:-'(not set)'}"

      - name: Test Python bindings functionality
        run: |
          echo "=========================================="
          echo "=== PYTHON BINDINGS DIAGNOSTIC ==="
          echo "=========================================="

          . /etc/pcp.conf
          PYTHON=${PCP_PYTHON_PROG:-python3}

          echo "Python version:"
          $PYTHON --version
          echo ""

          echo "Python module search paths:"
          $PYTHON -c "import sys; print('\n'.join(sys.path))"
          echo ""

          echo "=== Test 1: Import pcp.pmapi ==="
          $PYTHON -c "from pcp import pmapi; print('✓ pcp.pmapi import OK')" || {
            echo "✗ Failed to import pcp.pmapi"
            echo "Checking installation location..."
            find /usr/local -name "pmapi.py" 2>/dev/null || echo "pmapi.py not found"
            exit 1
          }
          echo ""

          echo "=== Test 2: Import cpmapi (C extension) ==="
          $PYTHON -c "import cpmapi; print('✓ cpmapi import OK')" || {
            echo "✗ Failed to import cpmapi"
            echo "Checking for cpmapi.so..."
            find /usr/local -name "cpmapi*.so" 2>/dev/null || echo "cpmapi.so not found"
            echo ""
            echo "Checking library dependencies..."
            CPMAPI_SO=$(find /usr/local -name "cpmapi*.so" 2>/dev/null | head -1)
            if [ -n "$CPMAPI_SO" ]; then
              echo "Found: $CPMAPI_SO"
              otool -L "$CPMAPI_SO" | grep libpcp || echo "No libpcp reference found"
            fi
            exit 1
          }
          echo ""

          echo "=== Test 3: Check cpmapi library linking ==="
          CPMAPI_SO=$(find /usr/local -name "cpmapi*.so" 2>/dev/null | head -1)
          if [ -n "$CPMAPI_SO" ]; then
            echo "cpmapi location: $CPMAPI_SO"
            echo "Library dependencies:"
            otool -L "$CPMAPI_SO"
            echo ""
            echo "Checking for rpath:"
            otool -l "$CPMAPI_SO" | grep -A2 LC_RPATH || echo "No rpath found"
          fi
          echo ""

          echo "=== Test 4: Run test_pcp.py with diagnostics ==="
          cd /var/lib/pcp/testsuite
          if [ -f src/test_pcp.py ]; then
            echo "Attempting to run test_pcp.py on archive..."
            timeout 10 $PYTHON src/test_pcp.py archives/pyapi.0 2>&1 | head -50 || {
              echo "✗ test_pcp.py failed or timed out"
              echo "Exit code: $?"
            }
          else
            echo "test_pcp.py not found in testsuite"
          fi

      - name: Run QA sanity tests
        env:
          MAKEFLAGS: ""  # Force serial make - no parallelism
          TERM: xterm-256color  # Fix terminal errors in test output
        run: |
          cd /var/lib/pcp/testsuite
          export TERM=xterm-256color  # Ensure TERM is set for subprocesses

          # If localconfig doesn't exist, make setup will run
          # Capture its output explicitly
          if [ ! -f localconfig ]; then
            echo "=== localconfig missing, running make setup explicitly ==="
            sudo -u pcpqa make setup 2>&1 | tee /tmp/make-setup.log || {
              echo ""
              echo "=== MAKE SETUP FAILED ==="
              echo "Full output saved to /tmp/make-setup.log"
              exit 1
            }
          fi

          sudo -u pcpqa ./check -g sanity -x not_in_ci

      - name: Upload QA logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qa-logs
          path: |
            /var/lib/pcp/testsuite/*.bad
            /var/lib/pcp/testsuite/*.full
            /var/lib/pcp/testsuite/check.log
            /var/log/pcp/
            /tmp/make-setup.log
          retention-days: 7
