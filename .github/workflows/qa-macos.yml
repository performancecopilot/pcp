name: macOS QA

on:
  workflow_dispatch:
  push:
    branches:
      - macos-qa-uplift

jobs:
  qa:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.ref_name }}

      - name: Update Homebrew
        run: brew update

      - name: Set up Python 3.13
        uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - name: Install python deps
        run: |
          python3 --version
          pip3 install --upgrade pip
          python3 -m venv pybuilddeps
          source pybuilddeps/bin/activate
          pip3 install setuptools wheel lxml openpyxl OrderedDict psycopg2-binary prometheus_client pyarrow pyodbc requests

      - name: Install Homebrew deps
        run: |
          brew install autoconf unixodbc valkey libuv

      - name: Enable TCP stats
        run: |
          echo "Enabling TCP statistics for testing..."
          sudo sysctl -w net.inet.tcp.disable_access_to_stats=0
          sysctl net.inet.tcp.disable_access_to_stats

      - name: Configure PCP
        run: |
          source pybuilddeps/bin/activate
          # Use realpath to resolve macOS symlinks (/etc -> /private/etc, /var -> /private/var)
          # This matches the configuration used in Makepkgs for darwin
          ETC=$(realpath /etc)
          VAR=$(realpath /var)
          ./configure --sysconfdir=$ETC --localstatedir=$VAR --prefix=/usr/local --with-qt=no

      - name: Build PCP
        run: |
          source pybuilddeps/bin/activate
          make -j$(sysctl -n hw.ncpu)

      - name: Create PCP users and groups
        run: |
          echo "Creating pcp user and group for daemons..."
          if ! dscl . -read /Groups/pcp &>/dev/null; then
            NEXT_GID=$(dscl . -list /Groups PrimaryGroupID | awk '{print $2}' | sort -n | tail -1)
            NEXT_GID=$((NEXT_GID + 1))
            sudo dscl . -create /Groups/pcp
            sudo dscl . -create /Groups/pcp PrimaryGroupID "$NEXT_GID"
            sudo dscl . -create /Groups/pcp RealName "PCP Group"
          fi
          if ! dscl . -read /Users/pcp &>/dev/null; then
            NEXT_UID=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
            NEXT_UID=$((NEXT_UID + 1))
            PCP_GID=$(dscl . -read /Groups/pcp PrimaryGroupID | awk '{print $2}')
            sudo dscl . -create /Users/pcp
            sudo dscl . -create /Users/pcp UserShell /usr/bin/false
            sudo dscl . -create /Users/pcp RealName "PCP System User"
            sudo dscl . -create /Users/pcp UniqueID "$NEXT_UID"
            sudo dscl . -create /Users/pcp PrimaryGroupID "$PCP_GID"
            sudo dscl . -create /Users/pcp NFSHomeDirectory /var/empty
          fi

          echo "Creating pcpqa user for testing..."
          if ! dscl . -read /Users/pcpqa &>/dev/null; then
            NEXT_UID=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1)
            NEXT_UID=$((NEXT_UID + 1))
            sudo dscl . -create /Users/pcpqa
            sudo dscl . -create /Users/pcpqa UserShell /bin/bash
            sudo dscl . -create /Users/pcpqa RealName "PCP QA User"
            sudo dscl . -create /Users/pcpqa UniqueID "$NEXT_UID"
            sudo dscl . -create /Users/pcpqa PrimaryGroupID 20
            sudo dscl . -create /Users/pcpqa NFSHomeDirectory /Users/pcpqa
            sudo mkdir -p /Users/pcpqa
            sudo chown pcpqa:staff /Users/pcpqa
          fi

      - name: Configure sudo for pcpqa
        run: |
          echo "Setting up passwordless sudo for pcpqa..."
          echo "pcpqa ALL=(ALL) NOPASSWD: ALL" | sudo tee /etc/sudoers.d/pcpqa
          sudo chmod 0440 /etc/sudoers.d/pcpqa

      - name: Install PCP
        run: sudo make install

      - name: Rebuild PMNS
        run: |
          echo "Building PMNS root file from installed PMDA namespaces..."

          # Source pcp.conf from the real location (macOS resolves /etc -> /private/etc)
          if [ -f /etc/pcp.conf ]; then
            . /etc/pcp.conf
          elif [ -f /private/etc/pcp.conf ]; then
            . /private/etc/pcp.conf
          else
            echo "::error::pcp.conf not found in /etc or /private/etc"
            exit 1
          fi

          echo "Available PCP environment variables:"
          env | grep ^PCP_ | sort

          if [ -z "$PCP_VAR_DIR" ]; then
            echo "::error::PCP_VAR_DIR not set - pcp.conf not sourced correctly"
            exit 1
          fi

          echo ""
          echo "Checking where PMNS admin files were actually installed..."
          echo "Checking /usr/local/libexec/pcp/pmns/:"
          ls -la /usr/local/libexec/pcp/pmns/ 2>/dev/null || echo "Directory does not exist!"

          echo ""
          echo "Checking /usr/local/share/pcp/lib/pmns/:"
          ls -la /usr/local/share/pcp/lib/pmns/ 2>/dev/null || echo "Directory does not exist!"

          echo ""
          echo "PMNS directory contents (symlinks):"
          sudo ls -la $PCP_VAR_DIR/pmns/ || true

          echo ""
          echo "Testing if Rebuild symlink is accessible..."
          cd $PCP_VAR_DIR/pmns
          if [ -f Rebuild ]; then
            echo "✓ Rebuild symlink is accessible as a file"
            ls -l Rebuild

            # Try to resolve to absolute path
            if command -v realpath >/dev/null 2>&1; then
              REBUILD_REAL=$(realpath Rebuild)
              echo "Resolved to: $REBUILD_REAL"
              if [ -f "$REBUILD_REAL" ]; then
                echo "✓ Real file exists at $REBUILD_REAL"
                REBUILD_PATH="$REBUILD_REAL"
              else
                echo "::error::Real file does not exist at $REBUILD_REAL"
                exit 1
              fi
            else
              # Fallback: just use the symlink directly
              echo "realpath not available, using symlink directly"
              REBUILD_PATH="./Rebuild"
            fi
          else
            echo "::error::Rebuild is not accessible"
            exit 1
          fi

          echo ""
          echo "Running Rebuild script: $REBUILD_PATH"
          sudo "$REBUILD_PATH" -v

          echo ""
          echo "PMNS directory contents after rebuild:"
          sudo ls -la $PCP_VAR_DIR/pmns/

          if [ -f "$PCP_VAR_DIR/pmns/root" ]; then
            echo "✓ PMNS root file created successfully"
            echo "First 20 lines of root file:"
            sudo head -20 $PCP_VAR_DIR/pmns/root
          else
            echo "::error::PMNS root file was not created!"
            exit 1
          fi

      - name: Verify localhost DNS
        run: |
          echo "=== Checking localhost resolution ==="
          echo "Contents of /etc/hosts:"
          cat /etc/hosts

          echo ""
          echo "Checking for localhost entries..."
          if ! grep -q "127.0.0.1.*localhost" /etc/hosts; then
            echo "WARNING: No IPv4 localhost entry found - adding it"
            echo "127.0.0.1 localhost" | sudo tee -a /etc/hosts
          fi
          if ! grep -q "::1.*localhost" /etc/hosts; then
            echo "WARNING: No IPv6 localhost entry found - adding it"
            echo "::1 localhost" | sudo tee -a /etc/hosts
          fi

          echo ""
          echo "Testing DNS resolution speed..."
          time dscacheutil -q host -a name localhost

      - name: Start pmcd
        run: |
          sudo launchctl bootstrap system /Library/LaunchDaemons/io.pcp.pmcd.plist
          sudo launchctl kickstart -p -k system/io.pcp.pmcd

          echo "Waiting for pmcd to become available..."
          TIMEOUT=180
          ELAPSED=0
          INTERVAL=3

          while [ $ELAPSED -lt $TIMEOUT ]; do
            echo "Checking if pmcd is responding (${ELAPSED}s elapsed)..."

            if pcp 2>/dev/null; then
              echo "✓ pmcd service is responding!"
              break
            fi

            if pminfo -h localhost -f hinv.ncpu 2>/dev/null; then
              echo "✓ pmcd is accepting connections!"
              break
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "::error::pmcd failed to start within $TIMEOUT seconds"
            echo ""
            echo "=== pmcd process status ==="
            pgrep pmcd && echo "pmcd is running (PID: $(pgrep pmcd))" || echo "pmcd NOT running"
            ps aux | grep pmcd | grep -v grep || echo "No pmcd process found"

            echo ""
            echo "=== pmcd.log ==="
            sudo cat /var/log/pcp/pmcd/pmcd.log 2>/dev/null || echo "No pmcd.log found"

            echo ""
            echo "=== launchctl status ==="
            sudo launchctl list io.pcp.pmcd || echo "Service not in launchctl list"

            echo ""
            echo "=== pmcd network connections ==="
            sudo lsof -i -P | grep pmcd || echo "No network connections"

            exit 1
          fi

          echo ""
          echo "pmcd started successfully"
          pcp

      - name: Start pmlogger
        run: |
          sudo launchctl bootstrap system /Library/LaunchDaemons/io.pcp.pmlogger.plist
          sudo launchctl kickstart -p -k system/io.pcp.pmlogger
          sleep 3
          echo "pmlogger instances:"
          pgrep -l pmlogger || echo "No pmlogger processes yet (may take a moment)"

      - name: Start pmie
        run: |
          sudo launchctl bootstrap system /Library/LaunchDaemons/io.pcp.pmie.plist
          sudo launchctl kickstart -p -k system/io.pcp.pmie
          sleep 3
          echo "pmie instances:"
          pgrep -l pmie || echo "No pmie processes yet (may take a moment)"

      - name: Set QA directory permissions
        run: |
          echo "Giving pcpqa ownership of QA directory..."
          sudo chown -R pcpqa:staff qa/

      - name: Run QA sanity tests
        run: |
          cd qa
          sudo -u pcpqa ./check -g sanity -x not_in_ci

      - name: Upload QA logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qa-logs
          path: |
            qa/*.bad
            qa/check.log
            /var/log/pcp/
          retention-days: 7
